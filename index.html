<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scala&#8217;s Types of Types</title>
<link rel="stylesheet" href="stylesheets/foundation.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="stylesheets/asciidoctor-pygments.css">
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>Scala&#8217;s Types of Types</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the-different-types-of-types-in-scala">1. The different types of&#8230; Types in Scala</a></li>
<li><a href="#work-in-progress">2. WORK IN PROGRESS</a></li>
<li><a href="#type-annotation">3. Type Annotation</a></li>
<li><a href="#unified-type-system-any-anyref-anyval">4. Unified Type System - Any, AnyRef, AnyVal</a></li>
<li><a href="#the-bottom-types-nothing-and-null">5. The Bottom Types - Nothing and Null</a></li>
<li><a href="#type-of-an-code-object-code">6. Type of an <code>object</code></a></li>
<li><a href="#type-variance-in-scala">7. Type Variance in Scala</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#traits-as-in-interfaces-with-implementation">7.1. Traits, as in "interfaces with implementation"</a></li>
<li><a href="#type-linearization-vs-the-diamond-problem">7.2. Type Linearization vs. The Diamond Problem</a></li>
</ul>
</li>
<li><a href="#refined-types-refinements">8. Refined Types (refinements)</a></li>
<li><a href="#type-alias">9. Type Alias</a></li>
<li><a href="#abstract-type-member">10. Abstract Type Member</a></li>
<li><a href="#self-recursive-type-span-style-color-red-span">11. Self-Recursive Type <span style="color:red">&#x2717;</span></a></li>
<li><a href="#type-constructor">12. Type Constructor</a></li>
<li><a href="#higher-order-kind">13. Higher-Order Kind</a></li>
<li><a href="#case-class">14. Case Class</a></li>
<li><a href="#value-class">15. Value Class</a></li>
<li><a href="#type-class-span-style-color-red-span">16. Type Class <span style="color:red">&#x2717;</span></a></li>
<li><a href="#universal-trait-span-style-color-red-span">17. Universal Trait <span style="color:red">&#x2717;</span></a></li>
<li><a href="#self-type-annotation">18. Self Type Annotation</a></li>
<li><a href="#phantom-type-span-style-color-red-span">19. Phantom Type <span style="color:red">&#x2717;</span></a></li>
<li><a href="#structural-type">20. Structural Type</a></li>
<li><a href="#path-dependent-type">21. Path Dependent Type</a></li>
<li><a href="#type-projection">22. Type Projection</a></li>
<li><a href="#existential-types">23. Existential Types</a></li>
<li><a href="#type-lambda-span-style-color-red-span">24. Type Lambda <span style="color:red">&#x2717;</span></a></li>
<li><a href="#specialized-types">25. Specialized Types</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#specialized">25.1. @specialized</a></li>
<li><a href="#miniboxing">25.2. Miniboxing</a></li>
</ul>
</li>
<li><a href="#delayed-init">26. Delayed Init</a></li>
<li><a href="#dynamic-type">27. Dynamic Type</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#applydynamic">27.1. applyDynamic</a></li>
<li><a href="#applydynamicnamed">27.2. applyDynamicNamed</a></li>
<li><a href="#selectdynamic">27.3. selectDynamic</a></li>
<li><a href="#updatedynamic">27.4. updateDynamic</a></li>
</ul>
</li>
<li><a href="#bibliography-and-kudos">28. Bibliography and kudos</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#reference-and-further-reading">28.1. Reference and further reading</a></li>
<li><a href="#thanks-and-kudos">28.2. Thanks and kudos</a></li>
<li><a href="#give-back-some-kudos">28.3. Give back some kudos!</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="the-different-types-of-types-in-scala"><a class="anchor" href="#the-different-types-of-types-in-scala"></a>1. The different types of&#8230; Types in Scala</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This blog post came into being after a few discussions about Types in Scala after some of JavaOne&#8217;s parties in 2013. After those discussions I figured that many questions are often repeated by different people, during their learning of Scala. I though that we didn&#8217;t have a full list of all tricks what we can to with Types in Scala, so I decided to write such a list - giving real life examples why we&#8217;d need these types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="work-in-progress"><a class="anchor" href="#work-in-progress"></a>2. WORK IN PROGRESS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While I&#8217;m working on this article since quite some time, there&#8217;s still MUCH to do!
For example Higher Kinds need a rewrite, there&#8217;s a lot of detail to be added in Self Type&#8217;s and lots and lots more. Check the todo file for more.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to help, please do! I&#8217;ll welcome any pull request, or suggestion (well, I&#8217;d prefer pull requests ;-).</p>
</div>
<div class="paragraph">
<p>Also, if you see a section marked with "<span style="color:red">&#x2717;</span>" it means that it needs re-work or that it&#8217;s not complete in some way.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-annotation"><a class="anchor" href="#type-annotation"></a>3. Type Annotation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scala has Type Inference, which means that we can skip telling the Type of something each time in the source code,
and instead we just use `val`s or `def`s without "saying the type explicitly in the source". This being explicit about
the type of something, is called an Type Annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Thing</span>
<span class="tok-k">def</span> <span class="tok-n">getThing</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Thing { } </span>

<span class="tok-c1">// without Type Annotation, the type is infered to be `Thing`</span>
<span class="tok-k">val</span> <span class="tok-n">infered</span> <span class="tok-k">=</span> <span class="tok-n">getThing</span>

<span class="tok-c1">// with Type Annotation</span>
<span class="tok-k">val</span> <span class="tok-n">thing</span><span class="tok-k">:</span> <span class="tok-kt">Thing</span> <span class="tok-o">=</span> <span class="tok-n">getThing</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In these situations, leaving out the Type Annotation is OK. Although you may decide to always annotate return types of public methods (<strong>that&#8217;s very good idea!</strong>) in order to make the code more self-documenting.</p>
</div>
<div class="paragraph">
<p>In case of doubt you can refer to the below hint-questions to wether or not, include a Type Annotation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Is it a parameter? <strong>Yes</strong>, you have to.</p>
</li>
<li>
<p>Is it a public methods return value? <strong>Yes</strong>, for self-documenting code and control over exported types.</p>
</li>
<li>
<p>Is it a recursive or overloaded methods return value? <strong>Yes</strong>, you have to.</p>
</li>
<li>
<p>Do you need to return a more general interface than the inferencer would find? <strong>Yes</strong>, otherwise you&#8217;d expose your implementation details for example.</p>
</li>
<li>
<p>Else&#8230; No, don&#8217;t include a Type Annotation.</p>
</li>
<li>
<p>Related hint: Including Type Annotations speeds up compilation, also it&#8217;s generally nice to see the return type of a method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So we put Type Annotations after value names. Having this said, let&#8217;s jump into the next topics, where these types will become
more and more interesting.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unified-type-system-any-anyref-anyval"><a class="anchor" href="#unified-type-system-any-anyref-anyval"></a>4. Unified Type System - Any, AnyRef, AnyVal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We refer to a Scala&#8217;s typesystem as being "unified" because there is a "Top Type", <code>Any</code>. <strong>This is different than Java</strong>, which has "special cases" in form of primitive types (<code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>boolean</code>), which do not extend Java&#8217;s "Almost-Top Type" - <code>java.lang.Object</code>.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="assets/img/scala-types.png" alt="Scala's Unified Type System">
</div>
</div>
<div class="paragraph">
<p>Scala takes on the idea of having one common Top Type for all Types by introducing <code>Any</code>. <code>Any</code> is a supertype of both <code>AnyRef</code> and <code>AnyVal</code>.</p>
</div>
<div class="paragraph">
<p><code>AnyRef</code> is the "object world" of Java (and the JVM), it corresponds to <code>java.lang.Object</code>, and is the supertype of all objects. <code>AnyVal</code> on the other hand represents the "value world" of Java, such as <code>int</code> and other JVM primitives.</p>
</div>
<div class="paragraph">
<p>Thanks to this hierarchy, we&#8217;re able to define methods taking <code>Any</code> - thus being compatible with both <code>scala.Int</code> instances as well as <code>java.lang.String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Person</span>

<span class="tok-k">val</span> <span class="tok-n">allThings</span> <span class="tok-k">=</span> <span class="tok-nc">ArrayBuffer</span><span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]()</span>

<span class="tok-k">val</span> <span class="tok-n">myInt</span> <span class="tok-k">=</span> <span class="tok-mi">42</span>             <span class="tok-c1">// Int, kept as low-level `int` during runtime</span>

<span class="tok-n">allThings</span> <span class="tok-o">+=</span> <span class="tok-n">myInt</span>         <span class="tok-c1">// Int (extends AnyVal)</span>
                           <span class="tok-c1">// has to be boxed (!) -&gt; becomes java.lang.Integer in the collection (!)</span>

<span class="tok-n">allThings</span> <span class="tok-o">+=</span> <span class="tok-k">new</span> <span class="tok-nc">Person</span><span class="tok-o">()</span>  <span class="tok-c1">// Person (extends AnyRef), no magic here</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the Typesystem it&#8217;s transparent, though on the JVM level once we get into <code>ArrayBuffer[Any]</code> our Int instances will have to be packed into objects. Let&#8217;s investigate the above example&#8217;s by using the Scala REPL and it&#8217;s <code>:javap</code> command (which shows the generated bytecode for our test class):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">35: invokevirtual #47  // Method myInt:()I
38: invokestatic  #53  // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
41: invokevirtual #57  // Method scala/collection/mutable/ArrayBuffer.$plus$eq:(Ljava/lang/Object;)Lscala/collection/mutable/ArrayBuffer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll notive that <code>myInt</code> is still carrying the value of a <code>int primitive</code> (this is visible as <code>I</code> at the end of the <code>myInt:()I</code> <strong>invokevirtual</strong> call). Then, right before adding it to the ArrayBuffer, scalac inserted a call to <code>BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer</code> (a small hint for not frequent bytecode readers, the method it calls is: <code>public Integer boxToInteger(i: int)</code>). This way, by having a smart compiler and treating everything as an object in this common hierarchy we&#8217;re able to get away from the "but primitives are different" edge-cases, at least at the level of our Scala source code - the compiler takes care of it for us. On JVM level, the distinction is still there of course, and scalac will do it&#8217;s best to keep using primitives wherever possible, as operations on them are faster, and take less memory (objects are obviously bigger than primitives).</p>
</div>
<div class="paragraph">
<p>On the other hand, we can limit a method to only be able to work on "lightweight" Value Types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">def</span> <span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-kt">AnyVal</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">()</span>

<span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-mi">42</span><span class="tok-o">)</span>    <span class="tok-c1">// Int -&gt; AnyVal</span>
<span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-mf">13.37</span><span class="tok-o">)</span> <span class="tok-c1">// Double -&gt; AnyVal</span>

<span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">Object</span><span class="tok-o">)</span> <span class="tok-c1">// -&gt; AnyRef = fails to compile</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example I&#8217;ve used a TypeClass <code>Checker[T]</code> and a type bound, which will be discussed below. The general idea is that this method will only take <a href="#value-class">Value Classes</a>, be it Int or our own Value Type. While probably not used very often, it shows how nicely the typesystem embraces java primitives, and brings them into the "real" type system, and not as a separate case, as is the case with Java.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-bottom-types-nothing-and-null"><a class="anchor" href="#the-bottom-types-nothing-and-null"></a>5. The Bottom Types - Nothing and Null</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Scala everything has "some" type&#8230; but have you ever wondered how the type inferencer can still work, and infer sound types when working with "weird" situations like throwing exceptions? Let&#8217;s investigate the below "if/else throw" example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">thing</span><span class="tok-k">:</span> <span class="tok-kt">Int</span> <span class="tok-o">=</span>
  <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">test</span><span class="tok-o">)</span>
    <span class="tok-mi">42</span>                             <span class="tok-c1">// : Int</span>
  <span class="tok-k">else</span>
    <span class="tok-k">throw</span> <span class="tok-k">new</span> <span class="tok-nc">Exception</span><span class="tok-o">(</span><span class="tok-s">&quot;Whoops!&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// : Nothing</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the comments, the type of the if block is <code>Int</code> (easy), the type of the else block is <code>Nothing</code> (interresting). The inferencer was able to infer that the <code>thing</code> value, will only ever be of type <code>Int</code>. This is because of the <strong>Bottom Type</strong> property of Nothing.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
A very nice intuition about how bottom types work is: <em>"<code>Nothing</code> extends everything."</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Type inference always looks for the "common type" of both branches in an if stamement, so if the other branch here is a Type that extends everything, the infered type will automatically be the Type from the first branch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Types</span> <span class="tok-n">visualized</span><span class="tok-k">:</span>

           <span class="tok-err">[</span><span class="tok-kt">Int</span><span class="tok-err">]</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">...</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">AnyVal</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">Any</span>
<span class="tok-nc">Nothing</span> <span class="tok-o">-&gt;</span> <span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">]</span> <span class="tok-o">-&gt;</span> <span class="tok-o">...</span> <span class="tok-o">-&gt;</span> <span class="tok-nc">AnyVal</span> <span class="tok-o">-&gt;</span> <span class="tok-nc">Any</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same reasoning can be applied to the second Bottom Type in Scala - <code>Null</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">thing</span><span class="tok-k">:</span> <span class="tok-kt">String</span> <span class="tok-o">=</span>
  <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">test</span><span class="tok-o">)</span>
    <span class="tok-s">&quot;Yay!&quot;</span>  <span class="tok-c1">// : String</span>
  <span class="tok-k">else</span>
  	<span class="tok-kc">null</span>    <span class="tok-c1">// : Null</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type of <code>thing</code> is as expected, String. <code>Null</code> follows ALMOST the same rules as Nothing. I&#8217;ll use this case to take a small detour to talk about inference, and the differences between AnyVals and AnyRefs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">Types visualized:

        [String] -> AnyRef -> Any
Null -> [String] -> AnyRef -> Any

infered type: String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s think about <code>Int</code> and other primitives, which cannot hold null values. To investigate this case let&#8217;s drop into the REPL and use the <code>:type</code> command (which allows to get the type of an expression):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala-repl language-scala-repl">scala> :type if (false) 23 else null
Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is different than the case with a String object in one of the branches. Let&#8217;s look into the types in detail here, as <code>Null</code> is a bit less "extends everything" than <code>Nothing</code>. Let&#8217;s see what <code>Int</code> extends in detail, by using <code>:type</code> again on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala-repl language-scala-repl">scala> :type -v 12
// Type signature
Int

// Internal Type structure
TypeRef(TypeSymbol(final abstract class Int extends AnyVal))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The verbose option adds a bit more information here, now we know that <code>Int</code> is an <code>AnyVal</code> - this is a special class representing value types - which cannot hold <code>Null</code>. If we look into <a href="https://github.com/scala/scala/blob/v2.10.3/src/library/scala/AnyVal.scala">AnyVal&#8217;s sources</a>, we&#8217;ll find:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">abstract</span> <span class="tok-k">class</span> <span class="tok-nc">AnyVal</span> <span class="tok-k">extends</span> <span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">NotNull</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;m bringing this up here because the core functionality of AnyVal is so nicely represented using the Types here. <strong>Notice the <code>NotNull</code> trait!</strong></p>
</div>
<div class="paragraph">
<p>Coming back to the subject why the common Type for our if statement with an <code>AnyVal</code> on one code block and a <code>null</code> on the other one was Any and not something else. The one sentence way to define it is: <code>Null extends all AnyRefs</code> whereas <code>Nothing extends anything</code>. As AnyVals (such as numbers), are not in the same tree as AnyRefs, the only common Type between a number and a <code>null</code> value is Any - which explains our case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Types</span> <span class="tok-n">visualized</span><span class="tok-k">:</span>

<span class="tok-kt">Int</span>  <span class="tok-kt">-&gt;</span> <span class="tok-kt">NotNull</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">AnyVal</span> <span class="tok-kt">-&gt;</span> <span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]</span>
<span class="tok-nc">Null</span>            <span class="tok-o">-&gt;</span> <span class="tok-nc">AnyRef</span> <span class="tok-o">-&gt;</span> <span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]</span>

<span class="tok-n">infered</span> <span class="tok-n">type</span><span class="tok-k">:</span> <span class="tok-kt">Any</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-of-an-code-object-code"><a class="anchor" href="#type-of-an-code-object-code"></a>6. Type of an <code>object</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scala `object`s are implemented via classes (obviously - as it&#8217;s the basic building block on the JVM),
but you&#8217;ll notice that we cannot get its type the same way as we would with an simple class&#8230;</p>
</div>
<div class="paragraph">
<p>I surprisingly often, would get the question on how to pass an object into a method. Just saying <code>obj: ExampleObj</code> won&#8217;t work
because that&#8217;s already referring to the instance, so there&#8217;s a member called <code>type</code> which should be used in such cases.</p>
</div>
<div class="paragraph">
<p>How it might look like in your code is explained by the below example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">ExampleObj</span>

<span class="tok-k">def</span> <span class="tok-n">takeAnObject</span><span class="tok-o">(</span><span class="tok-n">obj</span><span class="tok-k">:</span> <span class="tok-kt">ExampleObj.</span><span class="tok-k">type</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{}</span>

<span class="tok-n">takeAnObject</span><span class="tok-o">(</span><span class="tok-nc">ExampleObj</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-variance-in-scala"><a class="anchor" href="#type-variance-in-scala"></a>7. Type Variance in Scala</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Variance, in general, can be explained as "type compatible-ness" between types, forming an <code>extends</code> relation.
The most popular cases where you&#8217;ll have to deal with this is when working with containers or functions (so&#8230; surprisingly often!).</p>
</div>
<div class="paragraph">
<p>A major difference from Java in Scala is, that container types are <strong>not-variant by default</strong>!
This means that if you have a container defined as <code>Box[A]</code>, and then use it with an <code>Fruit</code> in place
of the type parameter <code>A</code>, you will not be able to insert an <code>Apple</code> (which <em>IS-A</em> <code>Fruit</code>) into it.</p>
</div>
<div class="paragraph">
<p>Variance in Scala is defined by using <code>+</code> and <code>-</code> signs in front of type parameters.</p>
</div>
<div class="paragraph">
<p><a href="http://www.slideshare.net/dgalichet/demystifying-scala-type-system">http://www.slideshare.net/dgalichet/demystifying-scala-type-system</a></p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;"> 
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Scala Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invariant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T'] and C[T] are <strong>not</strong> related</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Covariant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T'] is a subclass of C[T]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[+T]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contravariant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T] is a subclass of C[T']</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[-T]</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>The above table ilustrates all variance cases we&#8217;ll have to worry about - in an abstract way.
In case you&#8217;re wondering where you&#8217;d have to care about this - in fact, you&#8217;re exposed to this each time
you&#8217;re working with collections you&#8217;re being faced with the question "is it covariant?".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Most <em>immutable</em> collections are <em>covariant</em>, and most <em>mutable</em> collections are <em>invariant</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are (at least) two nice and very intuitive examples of this in Scala. One being "any collection", where we&#8217;ll use a <code>List[+A]</code> as our example, and functions. When talking about <code>List</code> in Scala, we usualy mean <code>scala.collection.immutable.List[+A]</code>, which is immutable as well as covariant, let&#8217;s look how this relates to building lists containing items of different types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Fruit</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Apple</span><span class="tok-o">()</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Orange</span><span class="tok-o">()</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>

<span class="tok-k">val</span> <span class="tok-n">l1</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">Apple</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">Apple</span><span class="tok-o">()</span> <span class="tok-o">::</span> <span class="tok-nc">Nil</span>
<span class="tok-k">val</span> <span class="tok-n">l2</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">Fruit</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">Orange</span><span class="tok-o">()</span> <span class="tok-o">::</span> <span class="tok-n">l1</span>

<span class="tok-c1">// and also, it&#39;s safe to prepend with &quot;anything&quot;,</span>
<span class="tok-c1">// as we&#39;re building a new list - not modifying the previous instance</span>

<span class="tok-k">val</span> <span class="tok-n">l3</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">AnyRef</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">::</span> <span class="tok-n">l2</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s worth mentioning that while <strong>having immutable collections co-variant is <em>safe</em></strong>, the same cannot be said about mutable collections. The classic example here is <code>Array[T]</code> which is <strong>invariant</strong>. Let&#8217;s look at what invariance means for us here, and how it saves us from mistakes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// won&#39;t compile</span>
<span class="tok-k">val</span> <span class="tok-n">a</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">Array</span><span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">](</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-mi">3</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such an assigment won&#8217;t compile, because of Array&#8217;s invariance. If this assignment would be valid, we&#8217;d run into the problem of being able to write such code: <code>a(0) = "" // ArrayStoreException!</code> which would fail with the dreaded <code>ArrayStoreException</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
We said that "most" immutable collections are covariant in scala. In case you&#8217;re curious, one example of an immutable collection which stands out from that, and is invariant, it&#8217;s <code>Set[A]</code>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="traits-as-in-interfaces-with-implementation"><a class="anchor" href="#traits-as-in-interfaces-with-implementation"></a>7.1. Traits, as in "interfaces with implementation"</h3>
<div class="paragraph">
<p>First, let&#8217;s take a look as the simplest thing possible about traits:
how we can basically treat a type with multiple traits mixed in, as if it is implementing these "interfaces with implementation",
as you might be tempted to call them if comming from Java-land:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Base</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">b</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">Cool</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">c</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">Awesome</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">a</span> <span class="tok-o">=</span><span class="tok-s">&quot;&quot;</span> <span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">BA</span> <span class="tok-k">extends</span> <span class="tok-nc">Base</span> <span class="tok-k">with</span> <span class="tok-nc">Awesome</span>
<span class="tok-k">class</span> <span class="tok-nc">BC</span> <span class="tok-k">extends</span> <span class="tok-nc">Base</span> <span class="tok-k">with</span> <span class="tok-nc">Cool</span>

<span class="tok-c1">// as you might expect, you can upcast these instances into any of the traits they&#39;ve mixed-in</span>
<span class="tok-k">val</span> <span class="tok-n">ba</span><span class="tok-k">:</span> <span class="tok-kt">BA</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">BA</span>
<span class="tok-k">val</span> <span class="tok-n">bc</span><span class="tok-k">:</span> <span class="tok-kt">Base</span> <span class="tok-kt">with</span> <span class="tok-kt">Cool</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">BC</span>

<span class="tok-k">val</span> <span class="tok-n">b1</span><span class="tok-k">:</span> <span class="tok-kt">Base</span> <span class="tok-o">=</span> <span class="tok-n">ba</span>
<span class="tok-k">val</span> <span class="tok-n">b2</span><span class="tok-k">:</span> <span class="tok-kt">Base</span> <span class="tok-o">=</span> <span class="tok-n">bc</span>

<span class="tok-n">ba</span><span class="tok-o">.</span><span class="tok-n">a</span>
<span class="tok-n">bc</span><span class="tok-o">.</span><span class="tok-n">c</span>
<span class="tok-n">b1</span><span class="tok-o">.</span><span class="tok-n">b</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So far this should have been relatively well known to you. Now let&#8217;s to into the world of the "diamond problem",
which people who know C++ might have been expecting. Basically "The Diamond Problem" is a situation during multiple inheritance
where we&#8217;re not sure to what we want to refer to. The below image ilustrates the problem, if you would think of traits as if they were
directly multiple inheritance:</p>
</div>
</div>
<div class="sect2">
<h3 id="type-linearization-vs-the-diamond-problem"><a class="anchor" href="#type-linearization-vs-the-diamond-problem"></a>7.2. Type Linearization vs. The Diamond Problem</h3>
<div class="paragraph">
<p>image::http://ktoso.github.io/scala-types-of-types/assets/img/220px-Diamond_inheritance.svg.png</p>
</div>
<div class="paragraph">
<p>For the "diamond problem" to appear, it&#8217;s enough if we have one overriding implementation in <code>B</code> or/and <code>C</code>. This introduces an ambiguity when calling the common method in <code>D</code>, did we inherit the version of the method from <code>C</code> or from <code>B</code>? In Scala&#8217;s case the case with only one overriding method is very simple - the override wins. But let&#8217;s work through the more complex case:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>class <code>A</code> defines a method <code>common</code> returning <code>a</code>,</p>
</li>
<li>
<p>trait <code>B</code> DOES override <code>common</code> to return <code>b</code>,</p>
</li>
<li>
<p>trait <code>C</code> DOES override <code>common</code> to return <code>c</code>,</p>
</li>
<li>
<p>class <code>D</code> extends both <code>B</code> and <code>C</code>,</p>
</li>
<li>
<p>which version of the <code>common</code> method does class <code>D</code> inherit? The overriden impementation from <code>C</code>, or theone from <code>B</code>?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This amgiguity is a pain point of every multiple-inheritance-like mechanism. Scala solves this problem by so called <strong>Type Linearization</strong>.
In other words, given a diamond class hierarchy, we are <strong>always</strong> (and <strong>deterministically</strong>) able to determine what will be called when inside D we call <code>common</code>.
Let&#8217;s put this into code and then talk about linearization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">A</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">common</span> <span class="tok-k">=</span> <span class="tok-s">&quot;A&quot;</span> <span class="tok-o">}</span>

<span class="tok-k">trait</span> <span class="tok-nc">B</span> <span class="tok-k">extends</span> <span class="tok-n">A</span> <span class="tok-o">{</span> <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">common</span> <span class="tok-k">=</span> <span class="tok-s">&quot;B&quot;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">C</span> <span class="tok-k">extends</span> <span class="tok-n">A</span> <span class="tok-o">{</span> <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">common</span> <span class="tok-k">=</span> <span class="tok-s">&quot;C&quot;</span> <span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">D1</span> <span class="tok-k">extends</span> <span class="tok-n">B</span> <span class="tok-k">with</span> <span class="tok-n">C</span>
<span class="tok-k">class</span> <span class="tok-nc">D2</span> <span class="tok-k">extends</span> <span class="tok-n">C</span> <span class="tok-k">with</span> <span class="tok-n">B</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results will be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-n">D1</span><span class="tok-o">).</span><span class="tok-n">common</span> <span class="tok-o">==</span> <span class="tok-s">&quot;C&quot;</span>

<span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-n">D2</span><span class="tok-o">).</span><span class="tok-n">common</span> <span class="tok-o">==</span> <span class="tok-s">&quot;B&quot;</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason for this is that Scala applied the type linearization for us here. The algorithm goes like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>start building a list of types, the first element is the type we&#8217;re linearizing right now,</p>
</li>
<li>
<p>expand each supertype recursively and put all their types into this list (it should be flat, not nested),</p>
</li>
<li>
<p>remove duplicates from the resulting list, by scanning it from the left, and removing a type that you&#8217;ve already "seen"</p>
</li>
<li>
<p>done.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s apply this algorithm on our diamond example by hand, to verify why <code>D1 extends B with C</code> (and <code>D2 extends C with B</code>) yielded the results they did:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// start with D1:</span>
<span class="tok-n">B</span> <span class="tok-k">with</span> <span class="tok-n">C</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>

<span class="tok-c1">// expand all the types until you rach Any for all of them:</span>
<span class="tok-o">(</span><span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">B</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">(</span><span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">C</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>

<span class="tok-c1">// remove duplicates by removing &quot;already seen&quot; types, when moving left-to-right:</span>
<span class="tok-o">(</span><span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">B</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">(</span>                            <span class="tok-n">C</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>

<span class="tok-c1">// write the resulting type nicely:</span>
<span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">B</span> <span class="tok-k">with</span> <span class="tok-n">C</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So when calling the <code>common</code> method, it&#8217;s now very simple to decide which version we want to call: we simply look at the linearized type,
and try to resolve the method by going from the right in the resulting linearized type. In the case of <code>D1</code>, the "rightmost" trait providing an implementation of <code>common</code> is <code>C</code>, so it&#8217;s overriding the implementation provided by <code>B</code>. The result of calling <code>common</code> inside <code>D1</code> would be <code>"c"</code>.</p>
</div>
<div class="paragraph">
<p>You can wrap your head around this method by trying it out on the <code>D2</code> class - it should linearize with <code>B</code> after <code>C</code>, thus yielding a <code>"b"</code> if you&#8217;d run the code.
Also it&#8217;s rather easy to resolve the simpler cases of linearization by just thinking "rightmost wins", but this is quite an simplification, which while helpful, does not give the full picture about the algorithm.</p>
</div>
<div class="paragraph">
<p>It is worth mentioning that using this technique we also know <strong>"who is my <code>super</code>?"</strong>. It&#8217;s as easy as "looking left" in the linearized type, from wherever class you want to check who your superclass is. So for example in our case (<code>D1</code>), the superclass of <code>C</code> is <code>B</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="refined-types-refinements"><a class="anchor" href="#refined-types-refinements"></a>8. Refined Types (refinements)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Refinements are very easy to explain as "subclassing without naming the subclass". So in source code it would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Entity</span>

<span class="tok-k">trait</span> <span class="tok-nc">Persister</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">doPersist</span><span class="tok-o">(</span><span class="tok-n">e</span><span class="tok-k">:</span> <span class="tok-kt">Entity</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-n">e</span><span class="tok-o">.</span><span class="tok-n">persistForReal</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-c1">// our refined instance (and type):</span>
<span class="tok-k">val</span> <span class="tok-n">refinedMockPersister</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Persister</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">doPersist</span><span class="tok-o">(</span><span class="tok-n">e</span><span class="tok-k">:</span> <span class="tok-kt">Entity</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-alias"><a class="anchor" href="#type-alias"></a>9. Type Alias</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s not really another kind of type, but a trick we can use to make our code more readable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">User</span> <span class="tok-o">=</span> <span class="tok-nc">String</span>
<span class="tok-k">type</span> <span class="tok-kt">Age</span> <span class="tok-o">=</span> <span class="tok-nc">Int</span>

<span class="tok-k">val</span> <span class="tok-n">data</span><span class="tok-k">:</span>  <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">User</span>, <span class="tok-kt">Age</span><span class="tok-o">]</span> <span class="tok-k">=</span>  <span class="tok-nc">Map</span><span class="tok-o">.</span><span class="tok-n">empty</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this trick the Map definition now suddenly "makes sense!". If we&#8217;d just used a <code>String =&gt; Int</code> map,
we&#8217;d make the code less readable. Here we can keep using our primitives (maybe we need this for performance etc),
but <strong>name them</strong> so it makes sense for the future reader of this class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="abstract-type-member"><a class="anchor" href="#abstract-type-member"></a>10. Abstract Type Member</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s now go deeper into the use cases of Type Aliases, which we call Abstract Type Members.</p>
</div>
<div class="paragraph">
<p>With Abstract Type Members we say "I expect someone to tell me about some type - I&#8217;ll refer to it by the name MyType".
It&#8217;s most basic function is allowing us to define generic classes (templates), but instead of using the <code>class Clazz[A, B]</code> syntax, we name them inside the class, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">SimplestContainer</span> <span class="tok-o">{</span>
  <span class="tok-k">type</span> <span class="tok-kt">A</span>      <span class="tok-c1">// Abstract Type Member</span>

  <span class="tok-k">def</span> <span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">A</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which for Java folks may seem very similar to the <code>Container&lt;A&gt;</code> syntax at first, but it&#8217;s a bit more powerful as we&#8217;ll see in the section about <a href="#path-dependent-type">Path Dependent Types</a>, as well as in the below example.</p>
</div>
<div class="paragraph">
<p>todo; Then, this is how we would implement this trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">IntContainer</span> <span class="tok-k">extends</span> <span class="tok-nc">SimplestContainer</span> <span class="tok-o">{</span>
  <span class="tok-k">type</span> <span class="tok-kt">A</span> <span class="tok-o">=</span> <span class="tok-nc">Int</span>

  <span class="tok-k">def</span> <span class="tok-n">value</span> <span class="tok-k">=</span> <span class="tok-mi">42</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we "provide the type" using a Type Alias on line 2 here, and now we can implement the value method, as its type is known.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="self-recursive-type-span-style-color-red-span"><a class="anchor" href="#self-recursive-type-span-style-color-red-span"></a>11. Self-Recursive Type <span style="color:red">&#x2717;</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>While this not being a Scala specific type, it still sometimes raises a few eyebrows. One example of a self-recursive type many of us are (perhaps unknowingly) familiar with, is Java&#8217;s <code>Enum&lt;E&gt;</code>, if you&#8217;re curious about it, check out the <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/Enum.java">Enum sources from Java</a>. But now back to Scala and first let&#8217;s see what we&#8217;re actually talking about.</p>
</div>
<div class="paragraph">
<p>Imagine you have some <code>Fruit</code> trait, and both an <code>Apple</code> and an <code>Orange</code> extend it. The Fruit trait also has an "compareTo" method, and here the problem comes up: imagine you&#8217;d want to say "<em>I can&#8217;t compare oranges with apples, they&#8217;re totally different things!</em>". First let&#8217;s look at how we loose this compile-time safety with the naive implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// naive impl, Fruit is NOT self-recursively parameterised</span>

<span class="tok-k">trait</span> <span class="tok-nc">Fruit</span> <span class="tok-o">{</span>
  <span class="tok-k">final</span> <span class="tok-k">def</span> <span class="tok-n">compareTo</span><span class="tok-o">(</span><span class="tok-n">other</span><span class="tok-k">:</span> <span class="tok-kt">Fruit</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span> <span class="tok-c1">// impl doesn&#39;t matter in our example, we care about compile-time</span>
<span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">Apple</span>  <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>
<span class="tok-k">class</span> <span class="tok-nc">Orange</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>

<span class="tok-k">val</span> <span class="tok-n">apple</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Apple</span><span class="tok-o">()</span>
<span class="tok-k">val</span> <span class="tok-n">orange</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Orange</span><span class="tok-o">()</span>

<span class="tok-n">apple</span> <span class="tok-n">compareTo</span> <span class="tok-n">orange</span> <span class="tok-c1">// compiles, but we want to make this NOT compile!</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So in the naive implementation, since the trait <code>Fruit</code> has no clue about the types extending it, so it&#8217;s not possible to restrict the compareTo signature to only allow "<em>the same subclass as `this`</em>" in the parameter. Let&#8217;s now rewrite this example to use an <strong>Self Recursive Type Parameter</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Fruit</span><span class="tok-o">[</span><span class="tok-kt">T</span> <span class="tok-k">&lt;:</span> <span class="tok-kt">Fruit</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">]]</span> <span class="tok-o">{</span>
  <span class="tok-k">final</span> <span class="tok-k">def</span> <span class="tok-n">compareTo</span><span class="tok-o">(</span><span class="tok-n">other</span><span class="tok-k">:</span> <span class="tok-kt">Fruit</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span> <span class="tok-c1">// impl doesn&#39;t matter in our example</span>
<span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">Apple</span>  <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span><span class="tok-o">[</span><span class="tok-kt">Apple</span><span class="tok-o">]</span>
<span class="tok-k">class</span> <span class="tok-nc">Orange</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span><span class="tok-o">[</span><span class="tok-kt">Orange</span><span class="tok-o">]</span>

<span class="tok-k">val</span> <span class="tok-n">apple</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Apple</span>
<span class="tok-k">val</span> <span class="tok-n">orange</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Orange</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the Type Parameter in Fruit&#8217;s signature. You could read it as "I take some <code>T</code>, that <code>T</code> must be a <code>Fruit[T]</code>", and the only way to satisfy such bounds is by extending this trait as we do with <code>Apple</code> and <code>Orange</code> now. Now if we&#8217;d try comparing <code>apple</code> to <code>orange</code> we&#8217;ll get a compile time error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="repl language-repl">scala> orange compareTo apple
<console>:13: error: type mismatch;
 found   : Apple
 required: Fruit[Orange]
              orange compareTo apple

scala> orange compareTo orange
res1: Boolean = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>So now we&#8217;re sure we&#8217;ll only ever compare apples with apples, and other Fruit with the same kind (<em>sub-class</em>) of <code>Fruit</code>. There&#8217;s more to discuss here though - what about subclasses of <code>Apple</code> and <code>Orange</code>? Well, because we "filled-in" the type parameter at Apple / Orange level in the type hierarchy, we basically said "apples can only be compared to apples", which means that sub-classes of apples, can be compared with each other - Fruit&#8217;s signature of <code>compareTo</code> will still be happy, because the right hand side of our call would be some <code>Fruit[Apple]</code>&#8201;&#8212;&#8201;only a bit more concrete, for example let&#8217;s try this with a japanese apple (ja. "", "ringo") and a polish apple (pl. "Jabuszko"):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">``</span>  <span class="tok-k">extends</span> <span class="tok-nc">Apple</span>
<span class="tok-k">object</span> <span class="tok-nc">Jabuszko</span> <span class="tok-k">extends</span> <span class="tok-nc">Apple</span>

<span class="tok-n">``</span> <span class="tok-n">compareTo</span> <span class="tok-nc">Jabuszko</span>
<span class="tok-c1">// true</span>
</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
You could get the same type-safety using more fancy tricks, like path dependent types or implicit parameters and type classes. But the simplest thing that does-the-job here would be this.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-constructor"><a class="anchor" href="#type-constructor"></a>12. Type Constructor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Type Constructors act pretty much like functions, but on the type level.
That is, if in normal programming you can have a function that takes a value <code>a</code> and returns a value <code>b</code> based on the previous one, then in type-level programming you&#8217;d think of a <code>List[+A]</code> being a type constructor, that is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List[+A]</code> takes a type parameter (<code>A</code>),</p>
</li>
<li>
<p>by itself it&#8217;s not a valid type, you need to fill in the <code>A</code> somehow - "<em>construct the type</em>",</p>
</li>
<li>
<p>by filling it in with <code>Int</code> you&#8217;d get <code>List[Int]</code> which is a concrete type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using this example, you can see how similar it is to normal constructors - with the only difference that here we work on types, and not instances of objects. It&#8217;s worth reminding here that in Scala it is not valid to say something is of type <code>List</code>, <strong>unlike in Java</strong> where javac would put the <code>List&lt;Object&gt;</code> for you. Scala is more strict here, and won&#8217;t allow us to use <code>just a List</code> in the place of a type, as it&#8217;s expecting a real type - not a type constructor.</p>
</div>
<div class="paragraph">
<p>Related to this subject is that with <strong>Scala 2.11.x</strong> we&#8217;re getting a new power user command in the REPL - the <code>:kind</code> command. It allows you to check if a type is higher kind or not. Let&#8217;s check it our on a simple type constructor, such as <code>List[+A]</code> first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// Welcome to Scala version 2.11.0-M5 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0-ea).</span>
<span class="tok-c1">// Type in expressions to have them evaluated.</span>

<span class="tok-k">:</span><span class="tok-kt">kind</span> <span class="tok-kt">List</span>
<span class="tok-c1">// scala.collection.immutable.List&#39;s kind is F[+A]</span>

<span class="tok-k">:</span><span class="tok-kt">kind</span> <span class="tok-kt">-v</span> <span class="tok-kt">List</span>
<span class="tok-c1">// scala.collection.immutable.List&#39;s kind is F[+A]</span>
<span class="tok-c1">// * -(+)-&gt; *</span>
<span class="tok-c1">// This is a type constructor: a 1st-order-kinded type.</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we see that scalac is able to tell us that <code>List</code>, in fact, is a type constructor (it&#8217;s way more talkative when used with the <code>-verbose option). Let's investigate the syntax right above this information: `* -&gt; *</code>. This syntax is widely used to represent kinds, and actually I found it quite Haskell inspired - as this is the syntax Haskell uses to print types of functions. The most intuitive way to read it out loud would be "takes one type, returns another type". You might have noticed that we&#8217;ve omitted something from Scala&#8217;s exact output, the plus sign from the relation (as in:<code>* -(+)-&gt; *</code>), this means variance bounds and you can read up in detail about variance in section <a href="#type-variance-in-scala">Type Variance in Scala</a>.</p>
</div>
<div class="paragraph">
<p>As already mentioned, <code>List[+A]</code> (or <code>Option[+A]</code>, or <code>Set[+A]</code>&#8230; or anything that has one type parameter) is the simplest case of a type constructor - these take <strong>one</strong> parameter.
We refer to them as <strong>first-order kinds</strong> (<code>* -&gt; *</code>). It&#8217;s also worth mentioning that even a <code>Pair[+A, +B]</code> (which we can represent as <code>* -&gt; * -&gt; *</code>) is still not a "higher-order kind" - it&#8217;s still <strong>first-order</strong>. In the next section we&#8217;ll dissect what exactly higher kinds give us and how to notice one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="higher-order-kind"><a class="anchor" href="#higher-order-kind"></a>13. Higher-Order Kind</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO nothing here yet, coming soon&#8230;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Higher Kinds</strong> on the other hand, allow us to abstract over type constructors, just like type constructors allow
us to abstract over the type they.</p>
</div>
<div class="paragraph">
<p>A classic example here is a <code>Monad</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala-repl language-scala-repl">scala> import scalaz._
import scalaz._

scala> :k Monad // Finds locally imported types.
Monad's kind is (* -> *) -> *
This is a type constructor that takes type constructor(s): a higher-kinded type.</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO: <a href="http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="case-class"><a class="anchor" href="#case-class"></a>14. Case Class</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
Is pulled in from PR and needs some fixes. TODO TODO
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Although very simple, let&#8217;s discuss what case classes give us. Example starts with simple java-like class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">SimpleCircle</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">radius</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>which generates something like this on JVM :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">scala> :javap SimpleCircle
public class SimpleCircle extends java.lang.Object{
    public double radius();
    public void radius_$eq(double);
    public JavaCircle(double);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but if we want it to behave like <a href="http://en.wikipedia.org/wiki/Value_object">Value Object</a>
we must override <code>equal</code> and <code>hashCode</code> methods (generate it by IDE). Now, scala for the rescue.</p>
</div>
<div class="paragraph">
<p>We can add prefix <code>case</code> to class like this (class name was changed to avoid clashes)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Circle</span><span class="tok-o">(</span><span class="tok-n">radius</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>and we gets class like this in runtime (not full :javap is here to achive more clear point of view)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">scala> :javap Circle
public class CaseCircle extends java.lang.Object implements scala.Serializable{
    public double radius();
    public CaseCircle copy(double);
    public double copy$default$1();
    public int hashCode();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public CaseCircle(double);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>as we can see, we have <code>equals</code>, <code>hashCode</code> and <code>toString</code> generated by compile and mark class as Serializable.</p>
</div>
<div class="paragraph">
<p>Also compile is so kind to generate copy method, it is importent becouse case classes are <strong>immutable</strong>.
We can modify it only by creation new object with updating changed value. Example should take away doubt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Point</span><span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-n">y</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">a</span> <span class="tok-k">=</span> <span class="tok-nc">Point</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">,</span> <span class="tok-mi">0</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">b</span> <span class="tok-k">=</span> <span class="tok-n">a</span><span class="tok-o">.</span><span class="tok-n">copy</span><span class="tok-o">(</span><span class="tok-n">y</span> <span class="tok-k">=</span> <span class="tok-mi">10</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">c</span> <span class="tok-k">=</span> <span class="tok-n">b</span><span class="tok-o">.</span><span class="tok-n">copy</span><span class="tok-o">(</span><span class="tok-n">x</span> <span class="tok-k">=</span> <span class="tok-mi">10</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>so point <code>b</code> have cordinates <code>(0, 10)</code>, and point <code>c</code> have <code>(10, 10)</code></p>
</div>
<div class="paragraph">
<p>More over, case class is equipted with extractor (also generate by compiler in companion object).
It can be used in pattern matching to simplified it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Crile</span><span class="tok-o">(</span><span class="tok-mf">2.5</span><span class="tok-o">)</span> <span class="tok-k">match</span> <span class="tok-o">{</span>
  <span class="tok-k">case</span> <span class="tok-nc">Circle</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Radius = &quot;</span> <span class="tok-o">+</span> <span class="tok-n">r</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>More about case class can be found in <a href="http://www.scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf#subsection.5.3.2">Scala Language Specification</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="value-class"><a class="anchor" href="#value-class"></a>15. Value Class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Value classes have been around in Scala for a long time internally, and you&#8217;ve used them already many times because all Number&#8217;s in Scala use this compiler trick to avoid boxing and unboxing numeric values from <code>int</code> to <code>scala.Int</code> etc. As a quick reminder, let&#8217;s recall that <code>Array[Int]</code> is an actual JVM <code>int[]</code> (or for bytecode happy people, it&#8217;s the JVM runtime type called: <code>[I</code>) which has tons of performance implications, but in one word&#8201;&#8212;&#8201;arrays of numbers are fast, arrays of references not as much.</p>
</div>
<div class="paragraph">
<p>Ok, since we now know the compiler has fancy tricks to avoid boxing <code>ints</code> into <code>Ints</code> when it doesn&#8217;t have to. Let&#8217;s see how this feature is exposed for us, end users since Scala 2.10.x. The feature is called "value classes", is fairly simple to apply to your existing classes. Using them is as simple as adding <code>extends AnyVal</code> to your class and following a few rules listed bellow. If you&#8217;re not familiar with <code>AnyVal</code>, this might be a good moment for a quick refresher by looking at Section <a href="#unified-type-system-any-anyref-anyval">Unified Type System - Any, AnyRef, AnyVal</a>.</p>
</div>
<div class="paragraph">
<p>For our example let&#8217;s implement a <code>Meter</code> which will serve as wrapper for plain <code>Int</code> and be able to convert the number of meters, into the number of type <code>Foot</code>. We need this class because no-one understands the imperial unit system ;-) On the downside though, why should we pay the runtime overhead of having an object around an <code>int</code> (that&#8217;s quite a few bytes (!) per instance) if for 95% of the time we&#8217;ll be using the plain meter value - because it&#8217;s a project for the european market? Value classes to the rescue!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Meter</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">AnyVal</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">toFeet</span><span class="tok-k">:</span> <span class="tok-kt">Foot</span> <span class="tok-o">=</span> <span class="tok-nc">Foot</span><span class="tok-o">(</span><span class="tok-n">value</span> <span class="tok-o">*</span> <span class="tok-mf">0.3048</span><span class="tok-o">)</span>
<span class="tok-o">}</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Foot</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">AnyVal</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">toMeter</span><span class="tok-k">:</span> <span class="tok-kt">Meter</span> <span class="tok-o">=</span> <span class="tok-nc">Meter</span><span class="tok-o">(</span><span class="tok-n">value</span> <span class="tok-o">/</span> <span class="tok-mf">0.3048</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll be using Case (Value) Classes in all our examples here, but it&#8217;s not technically required to do so (although very convinient). You could implement a Value Class using a normal class with one <code>val</code> parameter instead, but using case classes is usualy the best way to go. Why only one parameter you might ask&#8201;&#8212;&#8201;this is because we&#8217;ll try to avoid wrapping the value, and this only makes sense for single values, otherwise we&#8217;d have to keep a Tuple around somewhere, which gets fuzzy very quickly and we&#8217;d loose the performance of not-wrapping anyway. So remember - value classes work only for 1 value, although no-one said that that parameter must be a primitive (!), it can be a normal class, like <code>Fruit</code> or <code>Person</code>, we&#8217;ll still be able to avoid wrapping it in the Value Class at some times.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
All you need to do to define a Value Class is to have <strong>a class with only one public val parameter</strong> extending <code>AnyVal</code>, and follow a few restrictions around it. That one parameter does <em>not</em> have to be a primitive, it can be anything. The restrictions (or limitations) on the other hand are a longer list, as for example a value class cannot contain any other fields than <code>def</code> members and cannot be extended etc. For a full list and more in-depth examples refer to the Scala documentation&#8217;s <a href="http://docs.scala-lang.org/overviews/core/value-classes.html#summary_of_limitations">Value Classes - summary of limitations</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ok, so now that we got our <code>Meter</code> and <code>Foot</code> <strong>Value Case Classes</strong>, let&#8217;s first examine how the generated bytecode has changes from a normal case class when we added the <code>extends AnyVal</code> part, making Meter a value class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="java language-java"><span class="tok-c1">// case class</span>
<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-o">:</span><span class="tok-n">javap</span> <span class="tok-n">Meter</span>

<span class="tok-kd">public</span> <span class="tok-kd">class</span> <span class="tok-nc">Meter</span> <span class="tok-kd">extends</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-na">lang</span><span class="tok-o">.</span><span class="tok-na">Object</span> <span class="tok-kd">implements</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">Product</span><span class="tok-o">,</span><span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">Serializable</span><span class="tok-o">{</span>
    <span class="tok-kd">public</span> <span class="tok-kt">double</span> <span class="tok-nf">value</span><span class="tok-o">();</span>
    <span class="tok-kd">public</span> <span class="tok-n">Foot</span> <span class="tok-nf">toFeet</span><span class="tok-o">();</span>
    <span class="tok-c1">// ...</span>
<span class="tok-o">}</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-o">:</span><span class="tok-n">javap</span> <span class="tok-n">Meter$</span>
<span class="tok-kd">public</span> <span class="tok-kd">class</span> <span class="tok-nc">Meter</span><span class="tok-n">$</span> <span class="tok-kd">extends</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">runtime</span><span class="tok-o">.</span><span class="tok-na">AbstractFunction1</span> <span class="tok-kd">implements</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">Serializable</span><span class="tok-o">{</span>
    <span class="tok-c1">// ... (skipping not interesting in this use-case methods)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the bytecode generated for the value class bellow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="java language-java"><span class="tok-c1">// case value class</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-o">:</span><span class="tok-n">javap</span> <span class="tok-n">Meter</span>
<span class="tok-kd">public</span> <span class="tok-kd">final</span> <span class="tok-kd">class</span> <span class="tok-nc">Meter</span> <span class="tok-kd">extends</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-na">lang</span><span class="tok-o">.</span><span class="tok-na">Object</span> <span class="tok-kd">implements</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">Product</span><span class="tok-o">,</span><span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">Serializable</span><span class="tok-o">{</span>
    <span class="tok-kd">public</span> <span class="tok-kt">double</span> <span class="tok-nf">value</span><span class="tok-o">();</span>
    <span class="tok-kd">public</span> <span class="tok-n">Foot</span> <span class="tok-nf">toFeet</span><span class="tok-o">();</span>
    <span class="tok-c1">// ...</span>
<span class="tok-o">}</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-o">:</span><span class="tok-n">javap</span> <span class="tok-n">Meter$</span>
<span class="tok-kd">public</span> <span class="tok-kd">class</span> <span class="tok-nc">Meter</span><span class="tok-n">$</span> <span class="tok-kd">extends</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">runtime</span><span class="tok-o">.</span><span class="tok-na">AbstractFunction1</span> <span class="tok-kd">implements</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-na">Serializable</span><span class="tok-o">{</span>
    <span class="tok-kd">public</span> <span class="tok-kd">final</span> <span class="tok-n">Foot</span> <span class="tok-n">toFeet$extension</span><span class="tok-o">(</span><span class="tok-kt">double</span><span class="tok-o">);</span>
    <span class="tok-c1">// ...</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s basically one thing that should catch our attention here, it&#8217;s that the Meter&#8217;s companion class when created as a Value Class, has gained a new method - <code>toFeet$extension(double): Foot</code>. Before this method was an instance method, of the Meter class, and it did not take any arguments (so it was: <code>toFeet(): Foot</code>). The generated method is marked as "extension", and this is actualy exactly the name we give to such methods (.NET developers might see where this is headed already).</p>
</div>
<div class="paragraph">
<p>As our goal with Value Classes is to avoid having to allocate the entire value object, and instead work directly on the wrapped value we have to stop using instance methods&#8201;&#8212;&#8201;as they would force us into having an instance of the Wrapper (<code>Meter</code>) class. What we can do instead is promoting the instance method, into an <strong>extension method</strong>, which we&#8217;ll store in the companion object of <code>Meter</code>, and instead of using the <code>value: Double</code> field of the instance, we&#8217;ll <em>pass in</em> the <code>Double</code> value each time we&#8217;ll be calling the <strong>extension method</strong>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<strong>Extension methods</strong> serve the same purpose as <strong>Implicit conversions</strong> (which are a more general and more powerful utility), yet are better than conversions in one simple way&#8201;&#8212;&#8201;they avoid having to allocate the "Wrapper" object, which implicit conversions would otherwise use to provide the "added methods". Extension methods take the route of rewriting the generated methods a little, so that they take the type-to-be-extended as their 1st argument. So for example, if you write <code>3.toHexString</code> this method is added to <code>Int</code> via an <em>implicit conversion</em>, but as the <strong>target</strong> is <code>class RichInt extends AnyVal</code>, so a Value Class, the call does <em>not</em> force an allocation of <code>RichInt</code>, and instead will be rewriten into <code>RichInt$.$MODULE$.toHexString$extension(3)</code>, thus avoiding the allocation of <code>RichInt</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s now use our newly gained knowlage and investigate what the compiler will actualy do for us in the <code>Meter</code> example. Right next to the source code "as we write it", the comments will be explaining what the compiler actualy generates (thus, what happens when we run this code):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// source code                 // what the emited bytecode actualy does</span>

<span class="tok-k">val</span> <span class="tok-n">m</span><span class="tok-k">:</span> <span class="tok-kt">Meter</span>  <span class="tok-o">=</span> <span class="tok-nc">Meter</span><span class="tok-o">(</span><span class="tok-mf">12.0</span><span class="tok-o">)</span>    <span class="tok-c1">// store 12.0                                      </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="tok-k">val</span> <span class="tok-n">d</span><span class="tok-k">:</span> <span class="tok-kt">Double</span> <span class="tok-o">=</span> <span class="tok-n">m</span><span class="tok-o">.</span><span class="tok-n">value</span> <span class="tok-o">*</span> <span class="tok-mi">2</span>    <span class="tok-c1">// double multiply (12.0 * 2.0), store             </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="tok-k">val</span> <span class="tok-n">f</span><span class="tok-k">:</span> <span class="tok-kt">Foot</span>   <span class="tok-o">=</span> <span class="tok-n">m</span><span class="tok-o">.</span><span class="tok-n">toFeet</span>       <span class="tok-c1">// call Meter$.$MODULE$.toFeet$extension(12.0)     </span><i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>One might expect an allocation of a Meter object here, but as we&#8217;re using a Value Class, only the wrapped value gets stored - that is we&#8217;re working a plain <code>double</code> from here on, during <strong>runtime</strong> (assignment and typechecking still verifies "as if" this was a Meter instance)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we access the <code>value</code> of the Value Class (name of the field does not matter). Notice that the runtime operates on raw doubles here, and thus, does not have to call an <code>value</code> method, like it would have usualy if we&#8217;d use a plain case class.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we seem to be calling an instance method, defined on <code>Meter</code>, but in fact, the compiler has substituted this call with an extension method call, where it passes in the 12.0 value. We get back a Foot instance&#8230; oh wait! but <code>Foot</code> was also defined as Value Class, so in runtime we&#8217;d again get back a plain double! Source-code-wise we don&#8217;t have to care though - it&#8217;s nice if we get the performance gain from using a Value Class, but it does not affect our code in line 72 in any way.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These are the basics around extension methods and value classes. If you want to read more about the different edge-cases around them, please refer to the <a href="http://docs.scala-lang.org/overviews/core/value-classes.html">official documentaion&#8217;s section about Value Classes</a> where <strong>Mark Harrah</strong>, explains them very well with tons of examples, so I won&#8217;t be duplicating his effort here beyond the basic introduction :-)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-class-span-style-color-red-span"><a class="anchor" href="#type-class-span-style-color-red-span"></a>16. Type Class <span style="color:red">&#x2717;</span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Writes</span><span class="tok-o">[</span><span class="tok-kt">In</span>, <span class="tok-kt">Out</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">write</span><span class="tok-o">(</span><span class="tok-n">it</span><span class="tok-k">:</span> <span class="tok-kt">In</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Out</span>
<span class="tok-o">}</span>

<span class="tok-k">implicit</span> <span class="tok-k">val</span> <span class="tok-n">jsonWriter</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Writes</span><span class="tok-o">[</span><span class="tok-kt">Person</span>, <span class="tok-kt">Json</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">write</span><span class="tok-o">(</span><span class="tok-n">p</span><span class="tok-k">:</span> <span class="tok-kt">Person</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-nc">Json</span><span class="tok-o">.</span><span class="tok-n">toJson</span><span class="tok-o">(</span><span class="tok-n">p</span><span class="tok-o">)</span>
<span class="tok-o">}</span>

<span class="tok-k">implicit</span> <span class="tok-k">class</span> <span class="tok-nc">Writeable</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">write</span><span class="tok-o">[</span><span class="tok-kt">B</span><span class="tok-o">](</span><span class="tok-k">implicit</span> <span class="tok-n">writes</span><span class="tok-k">:</span> <span class="tok-kt">Writes</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">])</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="universal-trait-span-style-color-red-span"><a class="anchor" href="#universal-trait-span-style-color-red-span"></a>17. Universal Trait <span style="color:red">&#x2717;</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Universal traits are traits that <code>extend Any</code>, they should only have `def`s, and no initialization code.</p>
</div>
<div class="paragraph">
<p>TODO TODO</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO IMPLEMENT DOCS :-)
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="self-type-annotation"><a class="anchor" href="#self-type-annotation"></a>18. Self Type Annotation</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Self Types</strong> are used in order to "require" that, if another class uses this trait,
it should also provide implementation of whatever it is that you&#8217;re requireing.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example where a service requires some Module which provides other services.
We can state this using the following Self Type Annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Module</span> <span class="tok-o">{</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">serviceInModule</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ServiceInModule</span>
<span class="tok-o">}</span>

<span class="tok-k">trait</span> <span class="tok-nc">Service</span> <span class="tok-o">{</span>
  <span class="tok-k">this:</span> <span class="tok-kt">Module</span> <span class="tok-o">=&gt;</span>

  <span class="tok-k">def</span> <span class="tok-n">doTheThings</span><span class="tok-o">()</span> <span class="tok-k">=</span> <span class="tok-n">serviceInModule</span><span class="tok-o">.</span><span class="tok-n">doTheThings</span><span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second line can be read as "I&#8217;m a Module". It might seem yield the exactly same But how does this differ from extending <code>Module</code> right away?</p>
</div>
<div class="paragraph">
<p>which means that someone will have to give us this Module at instanciation time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">TestingModule</span> <span class="tok-k">extends</span> <span class="tok-nc">Module</span> <span class="tok-o">{</span> <span class="tok-cm">/*...*/</span> <span class="tok-o">}</span>

<span class="tok-k">new</span> <span class="tok-nc">Service</span> <span class="tok-k">with</span> <span class="tok-nc">TestingModule</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you were to try to instanciate it without mixing in the required trait it would fail like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">new</span> <span class="tok-nc">Service</span>

<span class="tok-c1">// class Service cannot be instantiated because it does not conform to its self-type Service with Module</span>
<span class="tok-c1">//              new Service</span>
<span class="tok-c1">//              ^</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should also keep in mind, that it&#8217;s OK, to specify more than one trait when using the self-type syntax.
And while we&#8217;re at it, let&#8217;s discuss why it is called self-type (except for the "yeah, it makes sense" factor). Turns out a popular style (and possibility) to write it looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Service</span> <span class="tok-o">{</span>
  <span class="tok-n">self</span><span class="tok-k">:</span> <span class="tok-kt">MongoModule</span> <span class="tok-kt">with</span> <span class="tok-kt">APIModule</span> <span class="tok-o">=&gt;</span>

  <span class="tok-k">def</span> <span class="tok-n">delegated</span> <span class="tok-k">=</span> <span class="tok-n">self</span><span class="tok-o">.</span><span class="tok-n">doTheThings</span><span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, you can use any identifier (not just <code>this</code> or <code>self</code>) and then refer to it from your class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="phantom-type-span-style-color-red-span"><a class="anchor" href="#phantom-type-span-style-color-red-span"></a>19. Phantom Type <span style="color:red">&#x2717;</span></h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO, needs a lot more love. For example "really phantom types" are not explained at all&#8201;&#8212;&#8201;those that we never construct.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Started</span>
<span class="tok-k">trait</span> <span class="tok-nc">Stopped</span>
<span class="tok-k">trait</span> <span class="tok-nc">StartStopState</span>
<span class="tok-k">trait</span> <span class="tok-nc">Started</span> <span class="tok-k">extends</span> <span class="tok-nc">StartStopState</span>
<span class="tok-k">trait</span> <span class="tok-nc">Stopped</span> <span class="tok-k">extends</span> <span class="tok-nc">StartStopState</span>

<span class="tok-k">class</span> <span class="tok-nc">Service</span><span class="tok-o">[</span><span class="tok-kt">State</span> <span class="tok-k">&lt;:</span> <span class="tok-kt">StartStopState</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">start</span><span class="tok-o">[</span><span class="tok-kt">T</span> <span class="tok-k">&gt;:</span> <span class="tok-kt">State</span> <span class="tok-k">&lt;:</span> <span class="tok-kt">Stopped</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">asInstanceOf</span><span class="tok-o">[</span><span class="tok-kt">Service</span><span class="tok-o">[</span><span class="tok-kt">Started</span><span class="tok-o">]]</span>
<span class="tok-o">}</span>
<span class="tok-k">val</span> <span class="tok-n">x</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Serice</span><span class="tok-o">[</span><span class="tok-kt">Stopped</span><span class="tok-o">]()</span>
<span class="tok-k">val</span> <span class="tok-n">x</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Service</span><span class="tok-o">[</span><span class="tok-kt">Stopped</span><span class="tok-o">]()</span>
<span class="tok-n">x</span><span class="tok-o">.</span><span class="tok-n">start</span>
<span class="tok-n">res1</span><span class="tok-o">.</span><span class="tok-n">start</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;re starting to get into the more interesting Types! :-)</p>
</div>
<div class="paragraph">
<p>Phantom Types are a mean of staticly validating your sources, during compile time.
It&#8217;s used in many libraries, to prevent you from using some API, with an object in "not the right state".</p>
</div>
<div class="paragraph">
<p>To set the stage for our Phantom Type usage let&#8217;s first define a <code>ServiceHandle</code> class,
and <code>trait`s to represent the state it is in. We want to prevent users of our API from calling `stop()</code> on an already
<code>Stopped</code> instance, as well as prevent them from calling <code>start()</code> on an already <code>Running</code> instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// the traits are expected to be only used with our ServiceHandle,</span>
<span class="tok-c1">// which we nicely express using Self Type Annotations.</span>
<span class="tok-k">trait</span> <span class="tok-nc">Stopped</span> <span class="tok-o">{</span> <span class="tok-k">this:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-o">=&gt;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">Running</span> <span class="tok-o">{</span> <span class="tok-k">this:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-o">=&gt;</span> <span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have our Types prepared, let&#8217;s look at how the implementation will look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">ServiceHandle</span> <span class="tok-k">private</span> <span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">Id</span><span class="tok-o">)</span>
<span class="tok-k">object</span> <span class="tok-nc">ServiceHandle</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">create</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">Id</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ServiceHandle</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-nc">Stopped</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, during instanciation of the class, we mix in the <code>Stopped</code> trait right away.
We&#8217;ve used this trick before in this blog post (series), but now it&#8217;s finally time to explain it in detail.</p>
</div>
<div class="paragraph">
<p>Turns out that the type of this newly created ServiceHandle is not only <code>ServiceHandle</code> but&#8230;
<code>ServiceHandle with Stopped</code>. It may seem underwhelming at first that "that&#8217;s it",
but let&#8217;s move on to the <code>start</code> and <code>stop</code> commands to see why this us so nice interesting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">def</span> <span class="tok-n">start</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-kt">with</span> <span class="tok-kt">Stopped</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">start</span><span class="tok-o">()</span>
  <span class="tok-k">new</span> <span class="tok-nc">ServiceHandle</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-nc">Running</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we can do the same for stopping a Service. Other useful methods would be,
<code>Id =&gt; Either[ServiceHandle with Stopped, ServiceHandle with Running]</code> which&#8217;s implementation you can easily imagine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">def</span> <span class="tok-n">stop</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-kt">with</span> <span class="tok-kt">Running</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">stop</span><span class="tok-o">()</span>
  <span class="tok-k">new</span> <span class="tok-nc">ServiceHandle</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-nc">Stopped</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO MAKE BETTER EXAMPLES</p>
</div>
<div class="paragraph">
<p>Fun Java Fact: A similar end-result - failing during compilation - can also be done in Java, using annotation processors and Annotated types (you should check out Adam Warski&#8217;s example on this if you&#8217;re curious).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="structural-type"><a class="anchor" href="#structural-type"></a>20. Structural Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Strucural Types are often described as "<strong>type-safe duck typing</strong>", which is quite a good comparison if you want to gain some intuition for it.</p>
</div>
<div class="paragraph">
<p>So far we&#8217;ve only been thinking about types in terms of "<strong>does it implement interface X?</strong>". With <strong>structural types</strong> we can go a step further and start reasoning
about the structure of a given object (hence the name). When checking whether a type matches using structual typing, we need to change our question to:"<strong>does it have a method with this signature?</strong>".</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at a very popular use-case in action, to see why it is so powerful. Imagine that you have many classes of things that can be <strong>closed</strong>. In Java-land one would usualy implement the <code>java.io.Closeable</code> interface in order to make it possible to write some common <code>Closeable</code> utility classes (in fact, <strong>Google Guava</strong> provides such a utility class). Now imagine that someone also implemented a <code>MyOwnCloseable</code> class but didn&#8217;t extend <code>java.io.Closeable</code>. Your <code>Closeables</code> library would not work here due to the static typing. You would not be able to pass instances of <code>MyOwnCloseable</code> into it. Let&#8217;s solve this problem using Structural Typing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">JavaCloseable</span> <span class="tok-o">=</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">io</span><span class="tok-o">.</span><span class="tok-nc">Closeable</span>
<span class="tok-c1">// reminder, it&#39;s body is: { def close(): Unit }</span>

<span class="tok-k">class</span> <span class="tok-nc">MyOwnCloseable</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">()</span>
<span class="tok-o">}</span>


<span class="tok-c1">// method taking a Structural Type</span>
<span class="tok-k">def</span> <span class="tok-n">closeQuietly</span><span class="tok-o">(</span><span class="tok-n">closeable</span><span class="tok-k">:</span> <span class="tok-o">{</span> <span class="tok-kt">def</span> <span class="tok-kt">close</span><span class="tok-o">()</span><span class="tok-kt">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">})</span> <span class="tok-k">=</span>
  <span class="tok-k">try</span> <span class="tok-o">{</span>
    <span class="tok-n">closeable</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
  <span class="tok-o">}</span> <span class="tok-k">catch</span> <span class="tok-o">{</span>
    <span class="tok-k">case</span> <span class="tok-n">ex</span><span class="tok-k">:</span> <span class="tok-kt">Exception</span> <span class="tok-o">=&gt;</span> <span class="tok-c1">// ignore...</span>
  <span class="tok-o">}</span>


<span class="tok-c1">// accepts a java.io.File (implements Closeable):</span>
<span class="tok-n">closeQuietly</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">StringReader</span><span class="tok-o">(</span><span class="tok-s">&quot;example&quot;</span><span class="tok-o">))</span>

<span class="tok-c1">// accepts a MyOwnCloseable</span>
<span class="tok-n">closeQuietly</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MyOwnCloseable</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The structural type is defined as a parameter to the method. It basically says that the only thing we expect from the type is that it should have this method. It could have more methods - so it&#8217;s not an exact match but the minimal set of methods a type has to define in order to be valid.</p>
</div>
<div class="paragraph">
<p>Another fact to keep in mind when using <strong>Structural Typing is that it actually has huge (negative) runtime performance implications, as it is actually implemented using reflection</strong>. We won&#8217;t look into the byte code for this case, but remember that it&#8217;s very easy to investigate the generated bytecode for scala (or java) classes, by using :javap in the Scala REPL. So you should try this out yourself.</p>
</div>
<div class="paragraph">
<p>Before we move over to the next subject, let&#8217;s briefly touch on a small but neat style tip. Imagine that your Structural Type is quite big, an example would be a type representing something that you can open, work on, and then must close. By using a Type Alias (described in detail in another section) with a Structural Type, we&#8217;re able to separate the type definition from the method, where we want to take in such instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">OpenerCloser</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span>
  <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span>
<span class="tok-o">}</span>

<span class="tok-k">def</span> <span class="tok-n">on</span><span class="tok-o">(</span><span class="tok-n">it</span><span class="tok-k">:</span> <span class="tok-kt">OpenerCloser</span><span class="tok-o">)(</span><span class="tok-n">fun</span><span class="tok-k">:</span> <span class="tok-kt">OpenerCloser</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-n">it</span><span class="tok-o">.</span><span class="tok-n">open</span><span class="tok-o">()</span>
  <span class="tok-n">fun</span><span class="tok-o">(</span><span class="tok-n">it</span><span class="tok-o">)</span>
  <span class="tok-n">it</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So using this type alias, we&#8217;ve made the <code>def</code> much cleaner. I&#8217;d highly recommend type aliasing bigger structural types. And one last warning, always check if you really need to reach for structural typing, and cannot do it in some other way, considering the negative performance impact.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="path-dependent-type"><a class="anchor" href="#path-dependent-type"></a>21. Path Dependent Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This Type allows us to type-check on a Type internal to another class. This may seem weird at first, but is very intuitive once you see it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Outer</span> <span class="tok-o">{</span>
  <span class="tok-k">class</span> <span class="tok-nc">Inner</span>
<span class="tok-o">}</span>

<span class="tok-k">val</span> <span class="tok-n">out1</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Outer</span>
<span class="tok-k">val</span> <span class="tok-n">out1in</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">out1</span><span class="tok-o">.</span><span class="tok-nc">Inner</span> <span class="tok-c1">// concrete instance, created from inside of Outer</span>

<span class="tok-k">val</span> <span class="tok-n">out2</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Outer</span>
<span class="tok-k">val</span> <span class="tok-n">out2in</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">out2</span><span class="tok-o">.</span><span class="tok-nc">Inner</span> <span class="tok-c1">// another instance of Inner, with the enclosing instance out2</span>

<span class="tok-c1">// the path dependent type. The &quot;path&quot; is &quot;inside out1&quot;.</span>
<span class="tok-k">type</span> <span class="tok-kt">PathDep1</span> <span class="tok-o">=</span> <span class="tok-n">out1</span><span class="tok-o">.</span><span class="tok-nc">Inner</span>


<span class="tok-c1">// type checks</span>

<span class="tok-k">val</span> <span class="tok-n">typeChecksOk</span><span class="tok-k">:</span> <span class="tok-kt">PathDep1</span> <span class="tok-o">=</span> <span class="tok-n">out1in</span>
<span class="tok-c1">// OK</span>

<span class="tok-k">val</span> <span class="tok-n">typeCheckFails</span><span class="tok-k">:</span> <span class="tok-kt">PathDep1</span> <span class="tok-o">=</span> <span class="tok-n">out2in</span>
<span class="tok-c1">// &lt;console&gt;:27: error: type mismatch;</span>
<span class="tok-c1">// found   : out2.Inner</span>
<span class="tok-c1">// required: PathDep1</span>
<span class="tok-c1">//    (which expands to)  out1.Inner</span>
<span class="tok-c1">//       val typeCheckFails: PathDep1 = out2in</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ey to understand here is that "each Outer class has its own Inner class", so it&#8217;s a different Type - dependent on which path we use to get there.</p>
</div>
<div class="paragraph">
<p>Using this kind of typing is useful, we&#8217;re able to enforce getting the type from inside of a concrete parameter. An example of a signature using this typing would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Parent</span> <span class="tok-o">{</span>
  <span class="tok-k">class</span> <span class="tok-nc">Child</span>
<span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">ChildrenContainer</span><span class="tok-o">(</span><span class="tok-n">p</span><span class="tok-k">:</span> <span class="tok-kt">Parent</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-k">type</span> <span class="tok-kt">ChildOfThisParent</span> <span class="tok-o">=</span> <span class="tok-n">p</span><span class="tok-o">.</span><span class="tok-nc">Child</span>

  <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">c</span><span class="tok-k">:</span> <span class="tok-kt">ChildOfThisParent</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">???</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the path dependent type we have now encoded in the type system, the logic,
that this container should only contain children of this parent - and not "any parent".</p>
</div>
<div class="paragraph">
<p>We&#8217;ll see how to require the "child of any parent" Type in the section about <a href="#type-projection">Type Projections</a> soon.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-projection"><a class="anchor" href="#type-projection"></a>22. Type Projection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Type Projections are similar to Path Dependent Types, in the way that they allow you to refer to a type of an inner class. In terms of syntax, you path your way into the structure of inner classes, splitting them with a <code>#</code> sign (hash sign, pound sign). Let&#8217;s start out by showing the first and main difference between these path dependent types (the "." syntax) vs. type projections (the "#" syntax):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// our example class structure</span>
<span class="tok-k">class</span> <span class="tok-nc">Outer</span> <span class="tok-o">{</span>
  <span class="tok-k">class</span> <span class="tok-nc">Inner</span>
<span class="tok-o">}</span>

<span class="tok-c1">// Type Projection (and alias) refering to Inner</span>
<span class="tok-k">type</span> <span class="tok-kt">OuterInnerProjection</span> <span class="tok-o">=</span> <span class="tok-nc">Outer</span><span class="tok-k">#</span><span class="tok-nc">Inner</span>

<span class="tok-k">val</span> <span class="tok-n">out1</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Outer</span>
<span class="tok-k">val</span> <span class="tok-n">out1in</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">out1</span><span class="tok-o">.</span><span class="tok-nc">Inner</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another nice intuition about path dependent vs. projections is that Type Projections can be used for "type level programming" ;-)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="existential-types"><a class="anchor" href="#existential-types"></a>23. Existential Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Existential Types are something that deeply relates to Type Erasure, which JVM languages "have to live with".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">thingy</span><span class="tok-k">:</span> <span class="tok-kt">Any</span> <span class="tok-o">=</span> <span class="tok-o">???</span>

<span class="tok-n">thingy</span> <span class="tok-k">match</span> <span class="tok-o">{</span>
  <span class="tok-k">case</span> <span class="tok-n">l</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">a</span><span class="tok-o">]</span> <span class="tok-k">=&gt;</span>
     <span class="tok-c1">// lower case &#39;a&#39;, matches all types... what type is &#39;a&#39;?!</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>We don&#8217;t know the type of <code>a</code>, because of runtime type erasure. We know though that List is a type constructor, <code>* -&gt; *</code>, so there must have been some type, it could have used to construct a valid <code>List[T]</code>. This "some type", is the <strong>existentional type</strong>!</p>
</div>
<div class="paragraph">
<p>Scala provides a shortcut for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">List</span><span class="tok-o">[</span><span class="tok-k">_</span><span class="tok-o">]</span>
 <span class="tok-c1">//  ^ some type, no idea which one!</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say you&#8217;re working with some Abstract Type Member, that in our case will be some Monad.
We want to force users of our class into using only <code>Cool</code> instances within this Monad, because for example,
only for these Types our Monad has any meaning. We can do this via Type Bounds on these <strong>Existential Type T</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">Monad</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">]</span> <span class="tok-k">forSome</span> <span class="tok-o">{</span> <span class="tok-k">type</span> <span class="tok-kt">T</span> <span class="tok-k">&gt;:</span> <span class="tok-kt">Cool</span> <span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://mikeslinn.blogspot.com/2012/08/scala-existential-types.html">http://mikeslinn.blogspot.com/2012/08/scala-existential-types.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-lambda-span-style-color-red-span"><a class="anchor" href="#type-lambda-span-style-color-red-span"></a>24. Type Lambda <span style="color:red">&#x2717;</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In type lambda&#8217;s we&#8217;ll be using <strong>Path Dependent</strong> as well as <strong>Structural Types</strong>, so if you skipped that sections you may want to go back to it.</p>
</div>
<div class="paragraph">
<p>Before we look at Type Lambdas, let&#8217;s take a step back and remind ourselfs a bit about functions and currying.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">EitherMonad</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">]</span> <span class="tok-nc">extends</span> <span class="tok-nc">Monad</span><span class="tok-o">[({</span><span class="tok-k">type</span> <span class="tok-kt"></span><span class="tok-o">[</span><span class="tok-kt"></span><span class="tok-o">]</span> <span class="tok-kt">=</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt"></span><span class="tok-o">]})</span><span class="tok-k">#</span><span class="tok-kt"></span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">point</span><span class="tok-o">[</span><span class="tok-kt">B</span><span class="tok-o">](</span><span class="tok-n">b</span><span class="tok-k">:</span> <span class="tok-kt">B</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">]</span>
  <span class="tok-k">def</span> <span class="tok-n">bind</span><span class="tok-o">[</span><span class="tok-kt">B</span>, <span class="tok-kt">C</span><span class="tok-o">](</span><span class="tok-n">m</span><span class="tok-k">:</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">])(</span><span class="tok-n">f</span><span class="tok-k">:</span> <span class="tok-kt">B</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">C</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">C</span><span class="tok-o">]</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="specialized-types"><a class="anchor" href="#specialized-types"></a>25. Specialized Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="specialized"><a class="anchor" href="#specialized"></a>25.1. @specialized</h3>
<div class="paragraph">
<p>Type specialization is actualy more of an performance technique than plain "type system stuff", but nevertheless it&#8217;s something very important and worth keeping in mind if you want to write well performing collections. For our example we&#8217;ll be implementing a very useful collection called <code>Parcel[A]</code>, which can hold a value of a given type&#8201;&#8212;&#8201;how useful indeed!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Parcel</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">](</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">A</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s our basic implementation. What&#8217;s the drawbacks here? Well, as <code>A</code> can be anything, it will be represented as an Java <strong>object</strong>, even if we&#8217;d only ever put <code>Int</code> into boxes. So the above class would cause us to box and unbox primitive values, because the container is working on objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">i</span><span class="tok-k">:</span> <span class="tok-kt">Int</span> <span class="tok-o">=</span> <span class="tok-nc">Int</span><span class="tok-o">.</span><span class="tok-n">unbox</span><span class="tok-o">(</span><span class="tok-nc">Parcel</span><span class="tok-o">.</span><span class="tok-n">apply</span><span class="tok-o">(</span><span class="tok-nc">Int</span><span class="tok-o">.</span><span class="tok-n">box</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)))</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we all know - boxing when you don&#8217;t really need to is not a good idea as it&#8217;s generating more work for the runtime with "back and forth" converting the <code>int</code> to <code>object Int</code>. What could do to fix this problem? One of the tricks to apply here is to "<strong>specialize</strong>" our Parcel for all primitive types (let&#8217;s say only <code>Long</code> and <code>Int</code> are good enough for now), like this:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
If you&#8217;ve already read about <a href="#value-class">Value Classes</a> you might have noticed that <code>Parcel</code> could be very nicely implemented using those instead! That is indeed true. However, <code>specialized</code> has been around in Scala since <code>2.8.1</code> and Value Classes were introduced recently in <code>2.10.x</code>. Also, <strong>you can specialize on more than one value</strong> (although it does <strong>exponentially</strong> (sic!) grow the generated code!), while with Value Classes you&#8217;re constrained to one value.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Parcel</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">](</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">A</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">something</span><span class="tok-k">:</span> <span class="tok-kt">A</span> <span class="tok-o">=</span> <span class="tok-o">???</span>
<span class="tok-o">}</span>

<span class="tok-c1">// specialzation &quot;by hand&quot;</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">IntParcel</span><span class="tok-o">(</span><span class="tok-n">intValue</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">something</span><span class="tok-k">:</span> <span class="tok-kt">Int</span> <span class="tok-o">=</span> <span class="tok-cm">/* works on low-level Int, no wrapping! */</span> <span class="tok-o">???</span>
<span class="tok-o">}</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">LongParcel</span><span class="tok-o">(</span><span class="tok-n">intValue</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">something</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-cm">/* works on low-level Long, no wrapping! */</span> <span class="tok-o">???</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementations inside <code>IntParcel</code> and <code>LongParcel</code> will efficiently avoid boxing, as they work directly on the primitives, and need not reach into the object realm. Now we just have to manualy select which <code>*Parcel</code> we want to use, depending on our use-case.</p>
</div>
<div class="paragraph">
<p>That&#8217;s all nice and good but&#8230; the code basically has just become far less maintanable, with <code>N</code> implementations, for each primitive that we want to support (which could be any of: <code>int</code>, <code>long</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>void</code>, plus the <code>Object</code> case)! That&#8217;s a lot of boilerplate to maintain.</p>
</div>
<div class="paragraph">
<p>Since we&#8217;re now familiar with the idea of specialization, and that it&#8217;s not really as nice to implement by hand, let&#8217;s see how Scala helps us out here by introducing the <code>@specialized</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Parcel</span><span class="tok-o">[</span><span class="tok-kt">@specialized</span> <span class="tok-kt">A</span><span class="tok-o">](</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">A</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we&#8217;re applying the <code>@specialized</code> annotation to the type parameter <code>A</code>, thus instructing the compiler to generate all specialized variants of this class - that is: <code>ByteParcel</code>, <code>IntParcel</code>, <code>LongParcel</code>, <code>FloatParcel</code>, <code>DoubleParcel</code>, <code>BooleanParcel</code>, <code>CharParcel</code>, <code>ShortParcel</code>, <code>CharParcel</code> and even <code>VoidParcel</code> (not actual names of the implementors, but you get the idea). Applying the "right" version is also taken up by the compiler, so we can write our code without caring if a class is specialized or not, and the compiler will do it&#8217;s best to use the specialized version (if available):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">pi</span> <span class="tok-k">=</span> <span class="tok-nc">Parcel</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>     <span class="tok-c1">// will use `int` specialized methods</span>
<span class="tok-k">val</span> <span class="tok-n">pl</span> <span class="tok-k">=</span> <span class="tok-nc">Parcel</span><span class="tok-o">(</span><span class="tok-mi">1L</span><span class="tok-o">)</span>    <span class="tok-c1">// will use `long` specialized methods</span>
<span class="tok-k">val</span> <span class="tok-n">pb</span> <span class="tok-k">=</span> <span class="tok-nc">Parcel</span><span class="tok-o">(</span><span class="tok-kc">false</span><span class="tok-o">)</span> <span class="tok-c1">// will use `boolean` specialized methods</span>
<span class="tok-k">val</span> <span class="tok-n">po</span> <span class="tok-k">=</span> <span class="tok-nc">Parcel</span><span class="tok-o">(</span><span class="tok-s">&quot;pi&quot;</span><span class="tok-o">)</span>  <span class="tok-c1">// will use `Object` methods</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>"<em>Great, so let&#8217;s use it everywhere!</em>"&#8201;&#8212;&#8201;is a common reaction when people find out about specialization, as it can speed-up low level operations multiple times with lowering memory usage at the same time! Sadly, <strong>it comes at a high price</strong>: the generated code quickly becomes huge when used with multiple parameters like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Thing</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">](</span><span class="tok-nd">@specialized</span> <span class="tok-n">a</span><span class="tok-k">:</span> <span class="tok-kt">A</span><span class="tok-o">,</span> <span class="tok-nd">@specialized</span> <span class="tok-n">b</span><span class="tok-k">:</span> <span class="tok-kt">B</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we&#8217;re using the second style of applying specialization - right onto the parameters - the effect is still the same as if we&#8217;d specialize <code>A</code> and <code>B</code> directly. Please notice that the above code would generate <code>8 * 8 = 64</code> (<em>sic!</em>) implementations, as it has to take care of cases like "A is an <code>int</code>, and B is an <code>int</code>" as well as "A is a <code>boolean</code>, but B is a <code>long</code>"&#8201;&#8212;&#8201;you can see where this is heading. In fact the number of generated classes is around <code>2 * 10^(nr_of_type_specializations)</code>, which easily reaches thousands of classes for already 3 type parameters!</p>
</div>
<div class="paragraph">
<p>There are ways to limit this exponential explosion, for example by limiting the specialization target types. Let&#8217;s say our <code>Parcel</code> will be used mosltly with integers, and never with floating point numbers&#8201;&#8212;&#8201;using this we can ask the compiler to only specialize for <code>Long</code> and <code>Int</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Parcel</span><span class="tok-o">[</span><span class="tok-kt">@specialized</span><span class="tok-o">(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span> <span class="tok-kt">A</span><span class="tok-o">](</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">A</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s also look into the bytecode a little bit this time, by using <code>:javap Parcel</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">// Parcel, specialized for Int and Long
public class Parcel extends java.lang.Object implements scala.Product,scala.Serializable{
    public java.lang.Object value(); // generic version, "catch all"
    public int value$mcI$sp();       // int specialized version
    public long value$mcJ$sp();}     // long specialized version

    public boolean specInstance$();  // method to check if we're a specialized class impl.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the compiler has prepared additional specialized methods for us, such as <code>value$mcI$sp()</code> returning an <code>int</code> and the same style of method for <code>long</code>. One other method worth mentioning here is <code>specInstance$</code> which returns <code>true</code> if the used implementation is a specialized class.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re curious, currently these classes are specialized in Scala (list may be incomplete): Function0, Function1, Function2, Tuple1, Tuple2, Product1, Product2, AbstractFunction0, AbstractFunction1, AbstractFunction2. Due to how costy it it to specialize beyond 2 parameters, it&#8217;s a trend to not specialize for more params, although certainly possible.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
A prime example why we want to avoid boxing is also memory efficiency. Imagine a <code>boolean</code>, it would be great if it would be stored as one bit, sadly it isn&#8217;t (not on any JVM I know of), for example on HotSpot an <code>boolean</code> is represented as <code>int</code>, so it takes <strong>4 bytes</strong> of space. It&#8217;s cousin <code>java.lang.Boolean</code> on the other hand has <strong>8 bytes of object header</strong>, as does any Java object, then it stores the <code>boolean</code> inside (another <strong>4 bytes</strong>), and due to the <strong>Java Object Layout alignment rules</strong>, the space taked up by this object will be aligned to <strong>16 bytes</strong> (8 for object header, 4 for the value, 4 bytes of padding). That&#8217;s yet another reason why we want to avoid boxing so badly.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="miniboxing"><a class="anchor" href="#miniboxing"></a>25.2. Miniboxing</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
This is not a Scala feature, but can be used with scalac as a <em>compiler plugin</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We&#8217;ve explained in the previous section that specialization is quite powerful, yet at the same time it&#8217;s a bit of a "compiler bomb", with it&#8217;s exponential growth potential. Turns out there is already a working proof of concept that takes away this problem. Miniboxing is a compiler plugin achieving the same result as <code>@specialized</code> but without generating thousands of classes.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO, there&#8217;s a project from withing EPFL to make specialization more efficient: scala-miniboxing.org[Scala Miniboxing]
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delayed-init"><a class="anchor" href="#delayed-init"></a>26. Delayed Init</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since we started talking about the "weird" types in Scala, we can&#8217;t let this one go without a dedicated section for it. <code>DelayedInit</code> is actually a "<em>compiler trick</em>" above anything else, and not really tremendously important for the type system itself, but once you understand it, you&#8217;ll know how <code>scala.App</code> actually works, so let&#8217;s dive into our example with <code>App</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">Main</span> <span class="tok-k">extends</span> <span class="tok-nc">App</span> <span class="tok-o">{</span>
  <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Hello world!&quot;</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>By looking at this code, and applying our basic Scala knowlage to it we might think "<em>Ok, so the <code>println</code> is actualy in the constructor of the Main class!</em>". And this would usually be true, but <strong>not in this case</strong>, since we inherited the <code>DelayedInit</code> trait - as <code>App</code> extends it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">App</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-c1">// code here ...</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s take a look at the full source code of the <code>DelayedInit</code> trait right away:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">delayedInit</span><span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-k">:</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, it does not contain any implementation - all the work around it is actually performed by the compiler, which will treat all classes and objects inheriting <code>DelayedInit</code> in a special way (note: trait&#8217;s will <em>not</em> be rewriten like this). The special treatment goes like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>imagine your class/object body is a function, doing all these things that are in the class/object body,</p>
</li>
<li>
<p>the compiler creates this function for you, and will pass it into the <code>delayedInit(x: =&gt; Unit)</code> method (notice the <em>call-by-name</em> in the parameter).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s quickly give an example for this, and then we&#8217;ll re-implement what <code>App</code> does for us, but by hand (and the help of <code>delayedInit</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// we write:</span>
<span class="tok-k">object</span> <span class="tok-nc">Main</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;hello!&quot;</span><span class="tok-o">)</span>
<span class="tok-o">}</span>

<span class="tok-c1">// the compiler emits:</span>
<span class="tok-k">object</span> <span class="tok-nc">Main</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">delayedInit</span><span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-k">:</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span> <span class="tok-k">=</span> <span class="tok-o">{</span> <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Hello!&quot;</span><span class="tok-o">)</span> <span class="tok-o">})</span> <span class="tok-k">=</span> <span class="tok-c1">// impl is left for us to fill in</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this mechanism you can run the body of your class whenever you want (&#8230; maybe never?). Since we now know how <code>delayedInit</code> works, let&#8217;s implement our own version of <code>scala.App</code> (which actually does it in exactly the same way).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">SimpleApp</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>

  <span class="tok-k">private</span> <span class="tok-k">val</span> <span class="tok-n">initCode</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">[()</span> <span class="tok-k">=&gt;</span> <span class="tok-kt">Unit</span><span class="tok-o">]</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">delayedInit</span><span class="tok-o">(</span><span class="tok-n">body</span><span class="tok-k">:</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span><span class="tok-o">)</span> <span class="tok-o">{</span>
    <span class="tok-n">initCode</span> <span class="tok-o">+=</span> <span class="tok-o">(()</span> <span class="tok-k">=&gt;</span> <span class="tok-n">body</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Whoa, I&#39;m a SimpleApp!&quot;</span><span class="tok-o">)</span>

    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">proc</span> <span class="tok-k">&lt;-</span> <span class="tok-n">initCode</span><span class="tok-o">)</span> <span class="tok-n">proc</span><span class="tok-o">()</span>

    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;So long and thanks for all the fish!&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

                                <span class="tok-c1">// Running the bellow class would print print:</span>
<span class="tok-k">object</span> <span class="tok-nc">Test</span> <span class="tok-k">extends</span> <span class="tok-nc">SimpleApp</span> <span class="tok-o">{</span> <span class="tok-c1">//</span>
                                <span class="tok-c1">// Whoa, I&#39;m a SimpleApp!</span>
  <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;  Hello World!&quot;</span><span class="tok-o">)</span>     <span class="tok-c1">//   Hello World!</span>
                                <span class="tok-c1">// So long and thanks for all the fish!</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it. Since the rewriting is <em>not</em> applied to traits, the code we see in our <code>SimpleApp</code> will not be modified by extending DelayedInit, thanks to this, we can make use of the delayedInit method and accumulate any "class bodies" that we encouter (imagine we&#8217;re dealing with a deep hierarchy of classes here, then the <code>delayedInit</code> would be called multiple times), and then we simply implement the <code>main</code> method like you would in plain Java land.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dynamic-type"><a class="anchor" href="#dynamic-type"></a>27. Dynamic Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I&#8217;ve had a hard time trying to decide if I should put this type into this vademecum of types or not. Lastly, I decided to add it, since it would make this collection of Type descriptions complete. So the question is, why did I hesistate so much?</p>
</div>
<div class="paragraph">
<p><strong>Scala allows us to have <strong>Dynamic Types</strong>, right inside of a Staticly/Strictly Typed language!</strong> Which is why I was considering to skip it, and leave a separate place for it&#8217;s description - as it&#8217;s basically "hacking around" all the descriptions you&#8217;ve seen above ;-) Let&#8217;s see it in action though, and how it fits into the Scala Type-ecosystem.</p>
</div>
<div class="paragraph">
<p>Imagine a class <code>JsonObject</code> which contains arbitrary JSON data. Let&#8217;s have methods, matching the keys of this JSON object, which would return an <code>Option[JValue]</code>, where a JValue can be another <code>JObject</code>, <code>JArray</code> or <code>JString</code> / <code>JNumber</code>. The usage would look like the example below.</p>
</div>
<div class="paragraph">
<p><strong>But before that, remember to enable this language feature in the given file (or REPL) via importing it.</strong>
There are a few features (like the experimental macros for example) that need to be explicitly imported in a file to be enabled. If you want to know more about these features, take a look at the [<code>scala.language</code>](<a href="http://www.scala-lang.org/api/current/index.html#scala.language$">http://www.scala-lang.org/api/current/index.html#scala.language$</a>) object or read the Scala Improvement Process 18 document ([SIP-18](<a href="https://docs.google.com/document/d/1nlkvpoIRkx7at1qJEZafJwthZ3GeIklTFhqmXMvTX9Q/edit)">https://docs.google.com/document/d/1nlkvpoIRkx7at1qJEZafJwthZ3GeIklTFhqmXMvTX9Q/edit)</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// remember, that we have to enable this language feature by importing it!</span>
<span class="tok-k">import</span> <span class="tok-nn">scala.language.dynamics</span>
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// TODO: Has missing implementation</span>
<span class="tok-k">class</span> <span class="tok-nc">Json</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-o">???</span>
<span class="tok-o">}</span>

<span class="tok-k">val</span> <span class="tok-n">jsonString</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;&quot;</span>
<span class="tok-s">  {</span>
<span class="tok-s">    &quot;name&quot;: &quot;Konrad&quot;,</span>
<span class="tok-s">    &quot;favLangs&quot;: [&quot;Scala&quot;, &quot;Go&quot;, &quot;SML&quot;]</span>
<span class="tok-s">  }</span>
<span class="tok-s">&quot;&quot;&quot;</span>

<span class="tok-k">val</span> <span class="tok-n">json</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Json</span><span class="tok-o">(</span><span class="tok-n">jsonString</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">Option</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">json</span><span class="tok-o">.</span><span class="tok-n">name</span>
<span class="tok-c1">// will compile (once we implement)!</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So&#8230; how do we fit this into an otherwise Statically Typed language? The answer is simple - compiler rewrites and a <strong>special marker trait</strong>: <code>scala.Dynamic</code>.</p>
</div>
<div class="paragraph">
<p>Ok, end of rant and back to the basics. So&#8230; How do we use Dynamic? In fact, it&#8217;s used by implementing a few "magic" methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>applyDynamic</strong></p>
</li>
<li>
<p><strong>applyDynamicNamed</strong></p>
</li>
<li>
<p><strong>selectDynamic</strong></p>
</li>
<li>
<p><strong>updateDynamic</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look (with examples, at each of them. We&#8217;ll start with the most "typical one", and move on to those which would allow the construct shown above (which didn&#8217;t (back then) compile) and make it work this time ;-)</p>
</div>
<div class="sect2">
<h3 id="applydynamic"><a class="anchor" href="#applydynamic"></a>27.1. applyDynamic</h3>
<div class="paragraph">
<p>Ok, our first magic method looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// applyDynamic example</span>
<span class="tok-k">object</span> <span class="tok-nc">OhMy</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">applyDynamic</span><span class="tok-o">(</span><span class="tok-n">methodName</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Any*</span><span class="tok-o">)</span> <span class="tok-o">{</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-s">&quot;&quot;&quot;|  methodName: $methodName,</span>
<span class="tok-s">                |args: ${args.mkString(&quot;,&quot;)}&quot;&quot;&quot;</span><span class="tok-o">.</span><span class="tok-n">stripMargin</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-nc">OhMy</span><span class="tok-o">.</span><span class="tok-n">dynamicMethod</span><span class="tok-o">(</span><span class="tok-s">&quot;with&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;some&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1337</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the signature of <strong>applyDynamic</strong> takes the method name and it&#8217;s arguments. So obviously we&#8217;d have to access them by their order. Very nice for building up some strings etc. Our implementation will only print what we want to know about the method being called. Did it really get the values/method name we would exect? The output would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-n">methodName</span><span class="tok-k">:</span> <span class="tok-kt">dynamicMethod</span><span class="tok-o">,</span>
  <span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">with</span><span class="tok-o">,</span><span class="tok-n">some</span><span class="tok-o">,</span><span class="tok-mi">1337</span>
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="applydynamicnamed"><a class="anchor" href="#applydynamicnamed"></a>27.2. applyDynamicNamed</h3>
<div class="paragraph">
<p>Ok, that was easy. But it didn&#8217;t give us too much control over the names of the parameters.
Wouldn&#8217;t it be nice if we could just write <code>JSON.node(nickname = "ktoso")</code>? Well&#8230; turns out we can!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// applyDynamicNamed example</span>
<span class="tok-k">object</span> <span class="tok-nc">JSON</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">applyDynamicNamed</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Any</span><span class="tok-o">)*)</span> <span class="tok-o">{</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-s">&quot;&quot;&quot;Creating a $name, for:\n &quot;${args.head._1}&quot;: &quot;${args.head._2}&quot; &quot;&quot;&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-nc">JSON</span><span class="tok-o">.</span><span class="tok-n">node</span><span class="tok-o">(</span><span class="tok-n">nickname</span> <span class="tok-k">=</span> <span class="tok-s">&quot;ktoso&quot;</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So this time instead of just a list of values, we also get their names. Thanks to this the response for this example will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Creating</span> <span class="tok-n">a</span> <span class="tok-n">node</span><span class="tok-o">,</span> <span class="tok-k">for:</span>
<span class="tok-err">&quot;</span><span class="tok-kt">nickname</span><span class="tok-err">&quot;</span><span class="tok-kt">:</span> <span class="tok-err">&quot;</span><span class="tok-kt">ktoso</span><span class="tok-err">&quot;</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>I can easily imagine some pretty slick &lt;strong&gt;DLSs&lt;/strong&gt; being built around this!</p>
</div>
</div>
<div class="sect2">
<h3 id="selectdynamic"><a class="anchor" href="#selectdynamic"></a>27.3. selectDynamic</h3>
<div class="paragraph">
<p>Not it&#8217;s time for the more "unusual" methods. apply methods we&#8217;re pretty easy to understand. It&#8217;s just a method with some arbitrary name. But hey, isn&#8217;t almost everything in scala a method - or we can have a method on an object that would act as a field? Yeah, so let&#8217;s give it a try! &lt;strong&gt;We&#8217;ll use the example with applyDynamic here, and try to act like it has a method without ()&lt;/strong&gt;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">OhMy</span><span class="tok-o">.</span><span class="tok-n">name</span> <span class="tok-c1">// compilation error</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hey! Why didn&#8217;t this work with &lt;strong&gt;applyDynamic&lt;/strong&gt;? Yeah, you figured it out already I guess. Such methods (without <code>()</code>) are treated <strong>special</strong>, as they would usualy represent fields for example. <code>applyDynamic</code> won&#8217;t trigger on such calls.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at our first <code>selectDynamic</code> call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Json</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">selectDynamic</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Option</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span>
    <span class="tok-n">parse</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">).</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And this time when we execute <code>HasStuff.bananas</code> we&#8217;ll get "I have bananas!" as expected. Notice that here we return a value instead of printing it. It&#8217;s because it "acts as a field" this time around. But we could also return things (of arbitrary types) from any other method described here (&lt;strong&gt;applyDynamic&lt;/strong&gt; &lt;strong&gt;could return the string instead of printing it&lt;/strong&gt;).</p>
</div>
</div>
<div class="sect2">
<h3 id="updatedynamic"><a class="anchor" href="#updatedynamic"></a>27.4. updateDynamic</h3>
<div class="paragraph">
<p>What&#8217;s left you ask? Ask yourself the following question then: "Since I can act like a <code>Dynamic</code> object has some value in some field&#8230; What else should I be able to do with it?" My answer to that would be: "set it"! That&#8217;s what <code>updateDynamic</code> is used for. There is one special rule about <code>updateDynamic</code> though - it&#8217;s only valid if you also took care about selectDynamic - that&#8217;s why in the first example the code generated errors about both - select and update. For example if we&#8217;d implement only updateDynamic, we would get an error that selectDynamic was not implemented and it wouldn&#8217;t compile anyway. It makes sense in terms of plain semantics if you think about it.</p>
</div>
<div class="paragraph">
<p>When we&#8217;re done with this example, we can actually make the (wrong) code from the first code snippet work. The below snippet will be an implementation of what was shown on the first snippet on that other website, and this time it&#8217;ll actually work ;-)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">MagicBox</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">box</span> <span class="tok-k">=</span> <span class="tok-n">mutable</span><span class="tok-o">.</span><span class="tok-nc">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Any</span><span class="tok-o">]()</span>

  <span class="tok-k">def</span> <span class="tok-n">updateDynamic</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">Any</span><span class="tok-o">)</span> <span class="tok-o">{</span> <span class="tok-n">box</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-n">value</span> <span class="tok-o">}</span>
  <span class="tok-k">def</span> <span class="tok-n">selectDynamic</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-n">box</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this &lt;strong&gt;Dynamic&lt;/strong&gt; "&lt;strong&gt;MagicBox&lt;/strong&gt;" we can store items at arbitrary "fields" (well, they do seem like fields, even though they are not ;-)). An example run might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">banana</span> <span class="tok-k">=</span> <span class="tok-s">&quot;banana&quot;</span>
<span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">banana</span><span class="tok-k">:</span> <span class="tok-kt">Any</span> <span class="tok-o">=</span> <span class="tok-n">banana</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">banana</span>
<span class="tok-n">res7</span><span class="tok-k">:</span> <span class="tok-kt">Any</span> <span class="tok-o">=</span> <span class="tok-n">banana</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">unknown</span>
<span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">NoSuchElementException</span><span class="tok-k">:</span> <span class="tok-kt">key</span> <span class="tok-kt">not</span> <span class="tok-kt">found:</span> <span class="tok-kt">unknown</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>By the way&#8230; are you curious how Dynamic &lt;a href="https://github.com/scala/scala/blob/master/src/library/scala/Dynamic.scala"&gt;[source code]&lt;/a&gt; is implemented? The fun part here is that the trait Dynamic, does absolutely nothing by itself - it&#8217;s "empty", just a marker interface. Obviously all the heavylifting (<strong>call-site-rewriting</strong>) is done by the compiler here.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bibliography-and-kudos"><a class="anchor" href="#bibliography-and-kudos"></a>28. Bibliography and kudos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="reference-and-further-reading"><a class="anchor" href="#reference-and-further-reading"></a>28.1. Reference and further reading</h3>
<div class="paragraph">
<p>Obviously this vademecum required quite a bit of reseach and double-checking, so here are all the links I&#8217;ve found helpful (and you might too).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Twitter&#8217;s Scala School: <a href="http://twitter.github.io/scala_school">http://twitter.github.io/scala_school</a> quite a bit of Scala concepts. Which helped me a lot in nicely explaining Variance (nicest explanation I found, since "ever").</p>
</li>
<li>
<p>Very old, but still valid explanation of Universal Types: <a href="http://www.scala-lang.org/old/node/128">http://www.scala-lang.org/old/node/128</a></p>
</li>
<li>
<p>Existential Types by D.R. MacIver: <a href="http://www.drmaciver.com/2008/03/existential-types-in-scala/">http://www.drmaciver.com/2008/03/existential-types-in-scala/</a></p>
</li>
<li>
<p>Scala Doc: <a href="http://www.scala-lang.org/api/current/index.html">http://www.scala-lang.org/api/current/index.html</a></p>
</li>
<li>
<p>Great presentation about introducing <code>@specialized</code> to Scala 2.8, by Dragos: <a href="http://days2010.scala-lang.org/node/138/151/15-7-E%20-%20Specialization%20-%20Dragos.pdf">Scala Days 2010 - Specialization</a></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Diamond_problem#The_diamond_problem">Wikipedia on the Diamond Problem</a></p>
</li>
<li>
<p><strong>Martin Odersky</strong>'s and <strong>Iulian Dragos</strong>'s whitepaper about specialization <a href="http://infoscience.epfl.ch/record/150134">Compiling generics through user-directed type specialization</a></p>
</li>
<li>
<p><a href="http://blog.jooq.org/2013/06/28/the-dangers-of-correlating-subtype-polymorphism-with-generic-polymorphism/">The dangers of correlating subtype polymorphism with generic polymorphism</a> blog post</p>
</li>
<li>
<p>Safari Books online about Type Linearization: <a href="http://blog.safaribooksonline.com/2013/05/30/traits-how-scala-tames-multiple-inheritance/">http://blog.safaribooksonline.com/2013/05/30/traits-how-scala-tames-multiple-inheritance/</a></p>
</li>
<li>
<p>One of the first blogs about Phantom Types in Scala: <a href="http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html">http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html</a></p>
</li>
<li>
<p>Rogue (where I occasionally PullRequest too) is a great example of using Phantom Types: <a href="http://engineering.foursquare.com/2011/01/31/going-rogue-part-2-phantom-types/">http://engineering.foursquare.com/2011/01/31/going-rogue-part-2-phantom-types/</a></p>
</li>
<li>
<p>Great StackOverflow answer by <strong>Kriss Nuttycombe</strong> about Type Lambdas: <a href="http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits">http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits</a></p>
</li>
<li>
<p>The :kind pull request to <code>scala</code>, by Adriaan Moors <a href="https://github.com/scala/scala/pull/2340">https://github.com/scala/scala/pull/2340</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="thanks-and-kudos"><a class="anchor" href="#thanks-and-kudos"></a>28.2. Thanks and kudos</h3>
<div class="paragraph">
<p>I would especialy like to thank all proof-readers and reviewers tha that have helped me with polishing this article and giving valuable feedback many many times (in chronological order :-)):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sergio Rodrigez, for the most in depth article review I&#8217;ve ever seen in my life and lots of suggestions,</p>
</li>
<li>
<p>Andrzej Grzesik, fellow <a href="http://java.pl">PolishJUG</a> / <a href="http://geecon.org">GeeCON</a> guy</p>
</li>
<li>
<p>Joshua Sureth, for the awesome comments and examples over lunch after devoxx</p>
</li>
<li>
<p>The awesome guys from <a href="http://softwaremill.com">SoftwareMill</a> for reviews and comments</p>
</li>
<li>
<p>The awesome guys from <a href="http://virtuslab.com">VirtusLab</a> for typo fixes, the makefile and suggestions</p>
</li>
<li>
<p>The <a href="http://www.krakowscala.pl">Krakw Scala User Group</a>'s members, for proof reading and suggestions</p>
</li>
<li>
<p>All the kind people who pull-requested typo&#8217;s and small fixes</p>
</li>
<li>
<p><em>TODO, there&#8217;s more people</em></p>
</li>
<li>
<p>You! Really. Thanks for reading this, you rock.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pull requests and comments are very welcome, if you&#8217;re up to it please go ahead, here&#8217;s the <a href="https://github.com/ktoso/scala-types-of-types">git repository</a>.</p>
</div>
<div class="paragraph">
<p>That&#8217;s all folks, and if it&#8217;s not, please ping me and I&#8217;ll update the guide. <em>Life is Study!</em>&#8201;&#8212;&#8201;<a href="mailto:konrad.malawski@java.pl">Konrad <em>ktoso</em> Malawski</a></p>
</div>
</div>
<div class="sect2">
<h3 id="give-back-some-kudos"><a class="anchor" href="#give-back-some-kudos"></a>28.3. Give back some kudos!</h3>
<div class="paragraph">
<p>If you liked this page, please share it with your friends using IRC any other chat service, or email, or social networks using these clicky-clicky buttons bellow! :-)</p>
</div>
<!-- Place this tag where you want the +1 button to render. -->
<div class="g-plusone"></div>

<!-- Place this tag after the last +1 button tag. -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/platform.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<a href="https://twitter.com/share" class="twitter-share-button" data-via="twitterapi" data-lang="en">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript" src="http://www.reddit.com/static/button/button1.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-2771927-19', 'ktoso.github.io');
  ga('send', 'pageview');

</script>
<style>
li.active {
  background: aliceblue;
}
</style>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://ktoso.github.io/scala-types-of-types/assets/js/bootstrap.min.js"></script>
<script>
$(document).ready(function() {
  $('#toc ul').addClass('nav nav-list');
  $('body').scrollspy({ target: '#toc' });
});
</script>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2013-12-22 00:20:24 CET
</div>
</div>
</body>
</html>
